{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"EDH_matchmaker","text":""},{"location":"#intro","title":"Intro","text":"<p>Long over due update on readme... here are some recent highlights. The CLI option is no longer supported. The program, for the time being, is meant for use through UI. Eventually, there will probably be some sort of Discord integration, but first, the rough edges have to be brushed out.</p>"},{"location":"#installation","title":"Installation:","text":"<p>The software was developed on Linux and installation should be rather straight forward. It's cross-platform, so I believe it should work on mac too, but I can't check. Either way, Windows has it's own issues, so here's how you do it.</p>"},{"location":"#windows","title":"Windows","text":"<p>First, you need python 3 and pip working. The easiest way to do this on Windows is by downloading the latest python version from official site (an installer). Generally, following default steps is OK, but you have to change one thing:</p> <p>Important: When installing, you have a couple of checkboxes. The one you want to tick is the \"Add python to PATH\" (or something similar).</p> <p>Now this should generally work, but sometimes, it doesn't. Ask Microsoft why.</p> <p>At any point during the following steps, you can check if python and pip are recognized in your command prompt/powershell. You can check it by running the command <code>python --version</code> and/or <code>pip --version</code>. If both are outputing something, you can skip the following steps, otherwise you have to troubleshoot your python installation and you can continue.</p> <p>To make sure it's added, go to your start menu, and search for \"Edit the system environment variables\". Might not be exact steps, but something along those lines (use google).</p> <p>Once you find it, depending on the version of Windows you have, you will have different sections. Search for \"Path\" variable and check if your python installation dirrectory is also added. Since this is not really the scope of this installation guide, you will have to figure this on your own as it can differ a bit from system to system, but generally something along those lines.</p> <p>Right, now that you've checked that python is actually in your Path variable, it's still possible that python is not recognized. Windows 10 can hide it behind some feature. I'll try to find what it was, but I think it was something along system integration of python or something. To be added.</p> <p>Rebooting your system might help the machine recognize python and pip if you're sure they're in your Path variable (especially on older versions of Windows).</p>"},{"location":"#once-python-is-sorted-the-actual-installation","title":"Once python is sorted, the actual installation","text":"<p>First, you have to install the require packages. This is rather simple. You have to open your command prompt/powershell/terminal in the directory where you've downloaded the software. On windows, you can do this from the file menu. I assume linux/mac users shouldn't have a problem here.</p> <p>The command is <code>pip install -r requirements.txt</code></p> <p>This will install the required libraries for the program to run.</p>"},{"location":"#running","title":"Running","text":"<p>Again, move to the directory and fire up:</p> <p><code>python run_ui.py</code></p> <p>On windows, you can also add a shortcut for this with different configurations.</p>"},{"location":"#runtime-options","title":"Runtime options","text":"<p>The program can also be run with some extra command parameters to set it up.</p> <p>You can check it by running <code>python run_ui.py --help</code>. Again, you can add a shortcut WITH those parameters, if you don't want to add them every time manually.</p> <p>Alternatively, you can also set everything up through GUI once the program is running.</p>"},{"location":"#closing-words","title":"Closing words","text":"<p>This software is still in development. The best thing you can do to help me is by testing it and submiting bugs. Best way to do it is here, on github - open an issue and describe what's happening and how to reproduce it, so I can fix it. You can also add your tournament log.</p> <p>Also you can star this project for more exposure :)</p> <p>Best regards, /E</p>"},{"location":"src/core/","title":"src.core","text":""},{"location":"src/core/#src.core.DataExport","title":"DataExport","text":"<p>Namespace for data export constants and enums.</p>"},{"location":"src/core/#src.core.DataExport.Format","title":"Format","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for export formats.</p>"},{"location":"src/core/#src.core.DataExport.Target","title":"Target","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for export targets.</p>"},{"location":"src/core/#src.core.Log","title":"Log","text":"<p>Handles logging messages with different severity levels.</p>"},{"location":"src/core/#src.core.Log.LogEntry","title":"LogEntry","text":"<pre><code>LogEntry(msg, level)\n</code></pre> <p>Represents a single log entry.</p> <p>Initializes a LogEntry.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <p>The log message.</p> required <code>level</code> <p>The severity level of the log.</p> required Source code in <code>src/core.py</code> <pre><code>def __init__(self, msg, level):\n    \"\"\"Initializes a LogEntry.\n\n    Args:\n        msg: The log message.\n        level: The severity level of the log.\n    \"\"\"\n    self.msg = msg\n    self.level = level\n</code></pre>"},{"location":"src/core/#src.core.Log.export","title":"export  <code>classmethod</code>","text":"<pre><code>export(fpath)\n</code></pre> <p>Exports the log to a file.</p> <p>Parameters:</p> Name Type Description Default <code>fpath</code> <p>The file path to export to.</p> required Source code in <code>src/core.py</code> <pre><code>@classmethod\ndef export(cls, fpath):\n    \"\"\"Exports the log to a file.\n\n    Args:\n        fpath: The file path to export to.\n    \"\"\"\n    try:\n        from pathlib import Path\n\n        Path(fpath).parent.mkdir(parents=True, exist_ok=True)\n        with open(fpath, \"w\") as f:\n            f.writelines([str(s) + \"\\n\" for s in cls.output])\n    except Exception as e:\n        cls.log(str(e), level=cls.Level.ERROR)\n</code></pre>"},{"location":"src/core/#src.core.Log.log","title":"log  <code>classmethod</code>","text":"<pre><code>log(str_log, level=Level.NONE)\n</code></pre> <p>Logs a message with a specified level.</p> <p>Parameters:</p> Name Type Description Default <code>str_log</code> <p>The message to log.</p> required <code>level</code> <p>The severity level (default: Level.NONE).</p> <code>NONE</code> Source code in <code>src/core.py</code> <pre><code>@classmethod\ndef log(cls, str_log, level=Level.NONE):\n    \"\"\"Logs a message with a specified level.\n\n    Args:\n        str_log: The message to log.\n        level: The severity level (default: Level.NONE).\n    \"\"\"\n    if cls.DISABLE:\n        return\n    entry = Log.LogEntry(str_log, level)\n    cls.output.append(entry)\n    if cls.PRINT:\n        print(entry)\n</code></pre>"},{"location":"src/core/#src.core.Log.print","title":"print  <code>classmethod</code>","text":"<pre><code>print()\n</code></pre> <p>Prints all log entries to the console.</p> Source code in <code>src/core.py</code> <pre><code>@classmethod\ndef print(cls):\n    \"\"\"Prints all log entries to the console.\"\"\"\n    for entry in cls.output:\n        print(entry)\n</code></pre>"},{"location":"src/core/#src.core.Player","title":"Player","text":"<pre><code>Player(tour: Tournament, name: str, uid: UUID | None = None, decklist: str | None = None)\n</code></pre> <p>               Bases: <code>IPlayer</code></p> <p>Represents a player in the tournament.</p> <p>Attributes:</p> Name Type Description <code>SORT_METHOD</code> <code>SortMethod</code> <p>The method used for sorting players (ID, Name, Rank).</p> <code>SORT_ORDER</code> <code>SortOrder</code> <p>The order used for sorting (Ascending, Descending).</p> <code>CACHE</code> <code>dict[UUID, Player]</code> <p>Global cache of player instances.</p> <p>Initializes a new Player instance.</p> <p>Parameters:</p> Name Type Description Default <code>tour</code> <code>Tournament</code> <p>The tournament the player belongs to.</p> required <code>name</code> <code>str</code> <p>The name of the player.</p> required <code>uid</code> <code>UUID | None</code> <p>The unique identifier for the player. If None, a new UUID is generated.</p> <code>None</code> <code>decklist</code> <code>str | None</code> <p>Optional URL or string representing the player's decklist.</p> <code>None</code> Source code in <code>src/core.py</code> <pre><code>def __init__(\n    self,\n    tour: Tournament,\n    name: str,\n    uid: UUID | None = None,\n    decklist: str | None = None,\n):\n    \"\"\"Initializes a new Player instance.\n\n    Args:\n        tour: The tournament the player belongs to.\n        name: The name of the player.\n        uid: The unique identifier for the player. If None, a new UUID is generated.\n        decklist: Optional URL or string representing the player's decklist.\n    \"\"\"\n    self._tour = tour.uid\n    super().__init__(uid=uid)\n    self.name = name\n    self.decklist = decklist\n    self.CACHE[self.uid] = self\n    self._pod_id: UUID | None = None  # Direct reference to current pod\n    self.table_preference: list[int] = []\n</code></pre>"},{"location":"src/core/#src.core.Player.average_seat","title":"average_seat","text":"<pre><code>average_seat(rounds: list[Round]) -&gt; np.float64\n</code></pre> <p>Expressed in percentage. In a 4 pod game:     seat 0: 100%     seat 1: 66.66%     seat 2: 33.33%     seat 3: 0% In a 3 pod game:     seat 0: 100%     seat 1: 50%     seat 2: 0%</p> <p>Higher percentage means better seats, statistically. In subsequent matching attempts, these will get lower priority on early seats.</p> <p>We are now using a weighted average of all the pods the player has been in. Weights are based on TC.global_wr_seats</p> Source code in <code>src/core.py</code> <pre><code>def average_seat(self, rounds: list[Round]) -&gt; np.float64:\n    \"\"\"\n    Expressed in percentage.\n    In a 4 pod game:\n        seat 0: 100%\n        seat 1: 66.66%\n        seat 2: 33.33%\n        seat 3: 0%\n    In a 3 pod game:\n        seat 0: 100%\n        seat 1: 50%\n        seat 2: 0%\n\n    Higher percentage means better seats, statistically.\n    In subsequent matching attempts, these will get lower priority on early seats.\n\n    We are now using a weighted average of all the pods the player has been in.\n    Weights are based on TC.global_wr_seats\n    \"\"\"\n    pods = [\n        self.pod(round)\n        for round in rounds\n        if self.pod(round) is not None and self.pod(round).done\n    ]\n    if not pods:\n        return np.float64(0.5)\n    n_pods = len([p for p in pods if isinstance(p, Pod)])\n    if n_pods == 0:\n        return np.float64(0.5)\n    score = 0\n    for pod in pods:\n        if isinstance(pod, Pod):\n            index = ([x.uid for x in pod.players]).index(self.uid)\n            if index == 0:\n                score += 1\n            elif index == len(pod) - 1:\n                continue\n            else:\n                rates = self.tour.config.global_wr_seats[0 : len(pod)]\n                norm_scale = 1 - (np.cumsum(rates) - rates[0]) / (\n                    np.sum(rates) - rates[0]\n                )\n                score += norm_scale[index]\n    return np.float64(score / n_pods)\n</code></pre>"},{"location":"src/core/#src.core.Player.byes","title":"byes","text":"<pre><code>byes(tour_round: Round | None = None)\n</code></pre> <p>Counts the number of byes received.</p> <p>Parameters:</p> Name Type Description Default <code>tour_round</code> <code>Round | None</code> <p>The round up to which to count.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <p>The number of byes.</p> Source code in <code>src/core.py</code> <pre><code>def byes(self, tour_round: Round | None = None):\n    \"\"\"Counts the number of byes received.\n\n    Args:\n        tour_round: The round up to which to count.\n\n    Returns:\n        int: The number of byes.\n    \"\"\"\n    if tour_round is None:\n        tour_round = self.tour.tour_round\n    return len([p for p in self.record(tour_round) if p is Player.EResult.BYE])\n</code></pre>"},{"location":"src/core/#src.core.Player.games","title":"games","text":"<pre><code>games(tour_round: Round | None = None)\n</code></pre> <p>Retrieves all completed games (pods) excluding byes and other non-game locations.</p> <p>Parameters:</p> Name Type Description Default <code>tour_round</code> <code>Round | None</code> <p>The round up to which to check.</p> <code>None</code> <p>Returns:</p> Type Description <p>list[Pod]: A list of actual completed game pods.</p> Source code in <code>src/core.py</code> <pre><code>def games(self, tour_round: Round | None = None):\n    \"\"\"Retrieves all completed games (pods) excluding byes and other non-game locations.\n\n    Args:\n        tour_round: The round up to which to check.\n\n    Returns:\n        list[Pod]: A list of actual completed game pods.\n    \"\"\"\n    if tour_round is None:\n        tour_round = self.tour.tour_round\n    return [p for p in self.pods(tour_round) if isinstance(p, Pod) and p.done]\n</code></pre>"},{"location":"src/core/#src.core.Player.played","title":"played","text":"<pre><code>played(tour_round: Round | None = None) -&gt; list[Player]\n</code></pre> <p>Retrieves a list of unique opponents played against in completed pods.</p> <p>Parameters:</p> Name Type Description Default <code>tour_round</code> <code>Round | None</code> <p>The round up to which to check.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Player]</code> <p>list[Player]: A list of unique opponents.</p> Source code in <code>src/core.py</code> <pre><code>def played(self, tour_round: Round | None = None) -&gt; list[Player]:\n    \"\"\"Retrieves a list of unique opponents played against in completed pods.\n\n    Args:\n        tour_round: The round up to which to check.\n\n    Returns:\n        list[Player]: A list of unique opponents.\n    \"\"\"\n    if tour_round is None:\n        tour_round = self.tour.tour_round\n    players = set()\n    for p in self.pods(tour_round):\n        if isinstance(p, Pod) and p.done:\n            players.update(p.players)\n    if players:\n        players.discard(self)\n    return list(players)\n</code></pre>"},{"location":"src/core/#src.core.Player.pods","title":"pods","text":"<pre><code>pods(tour_round: Round | None = None) -&gt; list[Pod | Player.ELocation]\n</code></pre> <p>Retrieves all pods or locations the player has been assigned to.</p> <p>Parameters:</p> Name Type Description Default <code>tour_round</code> <code>Round | None</code> <p>The round up to which to include pods.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Pod | ELocation]</code> <p>list[Pod|Player.ELocation]: A list of pods or location markers (e.g. BYE).</p> Source code in <code>src/core.py</code> <pre><code>def pods(self, tour_round: Round | None = None) -&gt; list[Pod | Player.ELocation]:\n    \"\"\"Retrieves all pods or locations the player has been assigned to.\n\n    Args:\n        tour_round: The round up to which to include pods.\n\n    Returns:\n        list[Pod|Player.ELocation]: A list of pods or location markers (e.g. BYE).\n    \"\"\"\n    if tour_round is None:\n        tour_round = self.tour.tour_round\n    pods: list[Pod | Player.ELocation] = [None for _ in range(tour_round.seq + 1)]  # type: ignore\n    tour_rounds = self.tour.rounds\n\n    for i, itr_round in enumerate(tour_rounds):\n        pod = itr_round.get_location(self)\n        if pod == None:\n            pods[i] = itr_round.get_location_type(self)\n        else:\n            pods[i] = pod\n        if itr_round == tour_round:\n            break\n    return pods\n</code></pre>"},{"location":"src/core/#src.core.Player.pointrate","title":"pointrate","text":"<pre><code>pointrate(tour_round: Round | None = None)\n</code></pre> <p>Calculates the point rate (actual points / maximum possible points).</p> <p>Parameters:</p> Name Type Description Default <code>tour_round</code> <code>Round | None</code> <p>The round up to which to calculate.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <p>The point rate.</p> Source code in <code>src/core.py</code> <pre><code>def pointrate(self, tour_round: Round | None = None):\n    \"\"\"Calculates the point rate (actual points / maximum possible points).\n\n    Args:\n        tour_round: The round up to which to calculate.\n\n    Returns:\n        float: The point rate.\n    \"\"\"\n    if len(self.games(tour_round)) == 0:\n        return 0\n    if tour_round is None:\n        tour_round = self.tour.tour_round\n    return self.rating(tour_round) / (\n        self.tour.config.win_points * (tour_round.seq + 1)\n    )\n</code></pre>"},{"location":"src/core/#src.core.Player.rating","title":"rating","text":"<pre><code>rating(tour_round: Round | None) -&gt; float\n</code></pre> <p>Calculates the player's rating (win percentage) up to a specific round.</p> <p>Parameters:</p> Name Type Description Default <code>tour_round</code> <code>Round | None</code> <p>The round up to which to calculate rating. If None, uses current round.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The rating as a decimal (0.0 to 1.0).</p> Source code in <code>src/core.py</code> <pre><code>def rating(self, tour_round: Round | None) -&gt; float:\n    \"\"\"Calculates the player's rating (win percentage) up to a specific round.\n\n    Args:\n        tour_round: The round up to which to calculate rating. If None, uses current round.\n\n    Returns:\n        float: The rating as a decimal (0.0 to 1.0).\n    \"\"\"\n    if tour_round is None:\n        return 0\n    return self.tour.rating(self, tour_round)\n</code></pre>"},{"location":"src/core/#src.core.Player.record","title":"record","text":"<pre><code>record(tour_round: Round | None = None) -&gt; list[Player.EResult]\n</code></pre> <p>Retrieves the full history of results.</p> <p>Parameters:</p> Name Type Description Default <code>tour_round</code> <code>Round | None</code> <p>The round up to which to retrieve the record.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[EResult]</code> <p>list[Player.EResult]: A chronological list of results.</p> Source code in <code>src/core.py</code> <pre><code>def record(self, tour_round: Round | None = None) -&gt; list[Player.EResult]:\n    \"\"\"Retrieves the full history of results.\n\n    Args:\n        tour_round: The round up to which to retrieve the record.\n\n    Returns:\n        list[Player.EResult]: A chronological list of results.\n    \"\"\"\n    seq = list()\n    if tour_round is None:\n        tour_round = self.tour.tour_round\n    pods: list[Pod | Player.ELocation] = []\n    for i, p in enumerate(self.pods(tour_round)):\n        # if i &lt; tour_round.seq:\n        pods.append(p)\n    for pod in pods:\n        if pod == Player.ELocation.BYE:\n            seq.append(Player.EResult.BYE)\n        elif pod == Player.ELocation.GAME_LOSS:\n            seq.append(Player.EResult.LOSS)\n        elif isinstance(pod, Pod):\n            if pod.result_type != Pod.EResult.PENDING:\n                if pod.result_type == Pod.EResult.WIN and self.uid in pod._result:\n                    seq.append(Player.EResult.WIN)\n                elif (\n                    pod.result_type == Pod.EResult.DRAW and self.uid in pod._result\n                ):\n                    seq.append(Player.EResult.DRAW)\n                else:\n                    seq.append(Player.EResult.LOSS)\n            else:\n                seq.append(Player.EResult.PENDING)\n    return seq\n</code></pre>"},{"location":"src/core/#src.core.Player.result","title":"result","text":"<pre><code>result(tour_round: Round) -&gt; Player.EResult\n</code></pre> <p>Retrieves the player's result for a specific round.</p> <p>Parameters:</p> Name Type Description Default <code>tour_round</code> <code>Round</code> <p>The round to query.</p> required <p>Returns:</p> Type Description <code>EResult</code> <p>Player.EResult: The result (WIN, LOSS, DRAW, BYE, PENDING).</p> Source code in <code>src/core.py</code> <pre><code>def result(self, tour_round: Round) -&gt; Player.EResult:\n    \"\"\"Retrieves the player's result for a specific round.\n\n    Args:\n        tour_round: The round to query.\n\n    Returns:\n        Player.EResult: The result (WIN, LOSS, DRAW, BYE, PENDING).\n    \"\"\"\n    if self.uid in tour_round._byes:\n        return Player.EResult.BYE\n    if self.uid in tour_round._game_loss:\n        return Player.EResult.LOSS\n    pod = self.pod(tour_round)\n    if pod and len(pod._result) &gt; 0:\n        if self.uid in pod._result:\n            if len(pod._result) == 1:\n                return Player.EResult.WIN\n            return Player.EResult.DRAW\n        else:\n            return Player.EResult.LOSS\n\n    return Player.EResult.PENDING\n</code></pre>"},{"location":"src/core/#src.core.Player.seat_history","title":"seat_history","text":"<pre><code>seat_history(tour_round: Round | None = None) -&gt; str\n</code></pre> <p>Generates a string representation of the player's seat history.</p> <p>Format: \"seat/pod_size\" for each round.</p> <p>Parameters:</p> Name Type Description Default <code>tour_round</code> <code>Round | None</code> <p>The round up to which to generate history.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The seat history string.</p> Source code in <code>src/core.py</code> <pre><code>def seat_history(self, tour_round: Round | None = None) -&gt; str:\n    \"\"\"Generates a string representation of the player's seat history.\n\n    Format: \"seat/pod_size\" for each round.\n\n    Args:\n        tour_round: The round up to which to generate history.\n\n    Returns:\n        str: The seat history string.\n    \"\"\"\n    if tour_round is None:\n        tour_round = self.tour.tour_round\n    pods = self.pods(tour_round)\n    if sum([1 for p in pods if isinstance(p, Pod) and p.done]) == 0:\n        return \"N/A\"\n    ret_str = \" \".join(\n        [\n            \"{}/{}\".format(\n                ([x.uid for x in p.players]).index(self.uid) + 1, len(p.players)\n            )\n            if isinstance(p, Pod)\n            else \"N/A\"\n            for p in pods\n        ]\n    )\n    return ret_str\n</code></pre>"},{"location":"src/core/#src.core.Player.set_result","title":"set_result","text":"<pre><code>set_result(tour_round: Round, result: EResult) -&gt; None\n</code></pre> <p>Sets the result for the player in a specific round.</p> <p>Parameters:</p> Name Type Description Default <code>tour_round</code> <code>Round</code> <p>The round where the result occurred.</p> required <code>result</code> <code>EResult</code> <p>The result to set (WIN, LOSS, DRAW, BYE).</p> required Source code in <code>src/core.py</code> <pre><code>def set_result(self, tour_round: Round, result: Player.EResult) -&gt; None:\n    \"\"\"Sets the result for the player in a specific round.\n\n    Args:\n        tour_round: The round where the result occurred.\n        result: The result to set (WIN, LOSS, DRAW, BYE).\n    \"\"\"\n    tour_round.set_result(self, result)\n</code></pre>"},{"location":"src/core/#src.core.Player.wins","title":"wins","text":"<pre><code>wins(tour_round: Round | None = None)\n</code></pre> <p>Counts the number of wins.</p> <p>Parameters:</p> Name Type Description Default <code>tour_round</code> <code>Round | None</code> <p>The round up to which to count.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <p>The number of wins.</p> Source code in <code>src/core.py</code> <pre><code>def wins(self, tour_round: Round | None = None):\n    \"\"\"Counts the number of wins.\n\n    Args:\n        tour_round: The round up to which to count.\n\n    Returns:\n        int: The number of wins.\n    \"\"\"\n    if tour_round is None:\n        tour_round = self.tour.tour_round\n    return len(\n        [\n            p\n            for p in self.games(tour_round)\n            if p.result_type == Pod.EResult.WIN and self.uid in p._result\n        ]\n    )\n</code></pre>"},{"location":"src/core/#src.core.Pod","title":"Pod","text":"<pre><code>Pod(tour_round: Round, table: int, cap=0, uid: UUID | None = None)\n</code></pre> <p>               Bases: <code>IPod</code></p> <p>Represents a single pod (table) in a round.</p> <p>Attributes:</p> Name Type Description <code>table</code> <code>int</code> <p>The table number.</p> <code>cap</code> <code>int</code> <p>The capacity of the pod (maximum number of players).</p> <code>_players</code> <code>list[UUID]</code> <p>List of player UUIDs in the pod.</p> <p>Initializes a new Pod instance.</p> <p>Parameters:</p> Name Type Description Default <code>tour_round</code> <code>Round</code> <p>The round the pod belongs to.</p> required <code>table</code> <code>int</code> <p>The table number.</p> required <code>cap</code> <p>The player capacity of the pod.</p> <code>0</code> <code>uid</code> <code>UUID | None</code> <p>Optional UUID.</p> <code>None</code> Source code in <code>src/core.py</code> <pre><code>def __init__(self, tour_round: Round, table: int, cap=0, uid: UUID | None = None):\n    \"\"\"Initializes a new Pod instance.\n\n    Args:\n        tour_round: The round the pod belongs to.\n        table: The table number.\n        cap: The player capacity of the pod.\n        uid: Optional UUID.\n    \"\"\"\n    self._tour: UUID = tour_round.tour.uid\n    self._round: UUID = tour_round.uid\n    super().__init__(uid=uid)\n    self.cap: int = cap\n    self._players: list[UUID] = list()\n</code></pre>"},{"location":"src/core/#src.core.Pod.balance","title":"balance  <code>property</code>","text":"<pre><code>balance: ndarray\n</code></pre> <p>Returns a list of count of players above 50% average seat and below 50% average seat</p>"},{"location":"src/core/#src.core.Pod.name","title":"name  <code>property</code>","text":"<pre><code>name\n</code></pre> <p>Returns the name of the pod. The name of the pod is \"Pod {}\".format(self.table).</p>"},{"location":"src/core/#src.core.Pod.players","title":"players  <code>property</code>","text":"<pre><code>players: list[Player]\n</code></pre> <p>Returns the list of players in the pod.</p>"},{"location":"src/core/#src.core.Pod.result","title":"result  <code>property</code>","text":"<pre><code>result: set[Player]\n</code></pre> <p>Retrieves the players involved in the result of the pod (e.g., winners or drawers).</p> <p>Returns:</p> Type Description <code>set[Player]</code> <p>set[Player]: A set of players.</p>"},{"location":"src/core/#src.core.Pod.table","title":"table  <code>property</code>","text":"<pre><code>table: int\n</code></pre> <p>Returns the table number of the pod. The table number is determined by the pod's index in the round's pod list (+1).</p>"},{"location":"src/core/#src.core.Pod.add_player","title":"add_player","text":"<pre><code>add_player(player: Player, manual=False, player_pod_map=None) -&gt; bool\n</code></pre> <p>Adds a player to the pod.</p> <p>Parameters:</p> Name Type Description Default <code>player</code> <code>Player</code> <p>The player to add.</p> required <code>manual</code> <p>If True, allows exceeding the pod's capacity.</p> <code>False</code> <code>player_pod_map</code> <p>Optional map to update player locations (internal use).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the player was added, False otherwise (e.g., if full and not manual).</p> Source code in <code>src/core.py</code> <pre><code>@override\ndef add_player(self, player: Player, manual=False, player_pod_map=None) -&gt; bool:\n    \"\"\"Adds a player to the pod.\n\n    Args:\n        player: The player to add.\n        manual: If True, allows exceeding the pod's capacity.\n        player_pod_map: Optional map to update player locations (internal use).\n\n    Returns:\n        bool: True if the player was added, False otherwise (e.g., if full and not manual).\n    \"\"\"\n    if len(self) &gt;= self.cap and self.cap and not manual:\n        return False\n    if pod := player.pod(self.tour_round):\n        pod.remove_player(player)\n    self.tour_round._byes.discard(player.uid)\n    self._players.append(player.uid)\n    self.tour_round.player_locations_map[player.uid] = self\n    # player.location = Player.ELocation.SEATED\n    # player.pod = self  # Update player's pod reference\n    return True\n</code></pre>"},{"location":"src/core/#src.core.Pod.auto_auto_assign_seats","title":"auto_auto_assign_seats","text":"<pre><code>auto_auto_assign_seats()\n</code></pre> <p>Assigns seats to players in the pod.</p> <p>Seat assignment attempts to balance seating positions based on players' history, giving preference to players who have had poor seat variance in the past.</p> Source code in <code>src/core.py</code> <pre><code>@override\ndef auto_auto_assign_seats(self):\n    \"\"\"Assigns seats to players in the pod.\n\n    Seat assignment attempts to balance seating positions based on players' history,\n    giving preference to players who have had poor seat variance in the past.\n    \"\"\"\n    # Average seating positions\n    average_positions = [\n        p.average_seat(self.tour.ended_rounds) for p in self.players\n    ]\n    n = len(average_positions)\n\n    if not any(average_positions):\n        random.shuffle(self.players)\n        return\n\n    # partially sort players based on seating positions\n    # those that have same average_seat should be randomly ordered\n    seat_assignment = [0] * n\n    for i in range(n):\n        seat_assignment[i] = (\n            sum([1 for x in average_positions if x &lt; average_positions[i]]) + 1\n        )\n    # randomize players with same average_seat\n    seat_assignment = [x + random.random() for x in seat_assignment]\n    # sort players based on seat assignment\n    self._players[:] = np.take(self._players, np.argsort(seat_assignment))\n\n    pass\n</code></pre>"},{"location":"src/core/#src.core.Pod.clear","title":"clear","text":"<pre><code>clear()\n</code></pre> <p>Clears the pod of all players. This method is called by the round when the pod is removed.</p> Source code in <code>src/core.py</code> <pre><code>def clear(self):\n    \"\"\"Clears the pod of all players.\n    This method is called by the round when the pod is removed.\n    \"\"\"\n    players = [p for p in self.players]\n    for p in players:\n        self.remove_player(p, cleanup=False)\n</code></pre>"},{"location":"src/core/#src.core.Pod.reorder_players","title":"reorder_players","text":"<pre><code>reorder_players(order: list[int]) -&gt; None\n</code></pre> <p>Reorders the players in the pod. Passing range(len(self._players)) will result no change in the order. Passing [0, 1, 2, 3] will result no change in the order. Passing [3, 2, 1, 0] will reverse the order of the players.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>list[int]</code> <p>A list of integers representing the new order of the players.</p> required Source code in <code>src/core.py</code> <pre><code>def reorder_players(self, order: list[int]) -&gt; None:\n    \"\"\"Reorders the players in the pod.\n    Passing range(len(self._players)) will result no change in the order.\n    Passing [0, 1, 2, 3] will result no change in the order.\n    Passing [3, 2, 1, 0] will reverse the order of the players.\n\n    Args:\n        order: A list of integers representing the new order of the players.\n    \"\"\"\n    if len(order) != len(self._players):\n        raise ValueError(\"Order must have the same length as the number of players\")\n    if any([x not in range(len(self._players)) for x in order]):\n        raise ValueError(\"Order must contain all integers from 0 to n-1\")\n    if len(set(order)) != len(order):\n        raise ValueError(\"Order must not contain duplicate integers\")\n\n    self._players[:] = np.take(self._players, order)\n</code></pre>"},{"location":"src/core/#src.core.PodsExport","title":"PodsExport","text":"<p>               Bases: <code>DataExport</code></p> <p>Handles the export of tournament pods.</p>"},{"location":"src/core/#src.core.PodsExport.auto_export","title":"auto_export  <code>classmethod</code>","text":"<pre><code>auto_export(func)\n</code></pre> <p>Decorator to automatically export pods after a function call.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to decorate.</p> required <p>Returns:</p> Type Description <p>The decorated function.</p> Source code in <code>src/core.py</code> <pre><code>@classmethod\ndef auto_export(cls, func):\n    \"\"\"Decorator to automatically export pods after a function call.\n\n    Args:\n        func: The function to decorate.\n\n    Returns:\n        The decorated function.\n    \"\"\"\n\n    def auto_pods_export_wrapper(\n        self: Tournament, *original_args, **original_kwargs\n    ):\n        try:\n            tour_round = self.tour_round\n        except (KeyError, ValueError):\n            tour_round = None\n        ret = func(self, *original_args, **original_kwargs)\n        try:\n            tour_round = tour_round or self.tour_round\n        except (KeyError, ValueError):\n            tour_round = None\n        if self.config.auto_export:\n            logf = TournamentAction.LOGF\n            if logf and tour_round:\n                # Export pods to a file named {tournament_name}_round_{round_number}.txt\n                # And also export it into {log_directory}/pods.txt\n                context = TournamentContext(\n                    self, tour_round, self.get_standings(tour_round)\n                )\n                export_str: str = \"\\n\\n\".join(\n                    [pod.__repr__(context=context) for pod in tour_round.pods]\n                )\n                game_lost: list[Player] = [\n                    x\n                    for x in tour_round.active_players\n                    if x.result == Player.EResult.LOSS\n                ]\n                byes = [\n                    x\n                    for x in tour_round.unassigned\n                    if x.location == Player.ELocation.UNASSIGNED\n                    and x.result == Player.EResult.BYE\n                ]\n                if len(game_lost) + len(byes) &gt; 0:\n                    max_len = max([len(p.name) for p in game_lost + byes])\n                    if self.config.allow_bye and byes:\n                        export_str += \"\\n\\nByes:\\n\" + \"\\n\".join(\n                            [\n                                \"\\t{} | pts: {}\".format(\n                                    p.name.ljust(max_len),\n                                    p.rating(tour_round) or \"0\",\n                                )\n                                for p in tour_round.unassigned\n                                if p.result == Player.EResult.BYE\n                            ]\n                        )\n                    if game_lost:\n                        export_str += \"\\n\\nGame losses:\\n\" + \"\\n\".join(\n                            [\n                                \"\\t{} | pts: {}\".format(\n                                    p.name.ljust(max_len), p.rating(tour_round)\n                                )\n                                for p in game_lost\n                            ]\n                        )\n\n                path = os.path.join(\n                    os.path.dirname(logf),\n                    os.path.basename(logf).replace(\".json\", \"\"),\n                    os.path.basename(logf).replace(\n                        \".json\", \"_R{}.txt\".format(tour_round.seq)\n                    ),\n                )\n                if not os.path.exists(os.path.dirname(path)):\n                    os.makedirs(os.path.dirname(path))\n\n                self.export_str(export_str, path, DataExport.Target.FILE)\n                if os.getenv(\"EXPORT_ONLINE_API_URL\") and os.getenv(\n                    \"EXPORT_ONLINE_API_KEY\"\n                ):\n                    self.export_str(export_str, None, DataExport.Target.WEB)\n\n                path = os.path.join(os.path.dirname(logf), \"pods.txt\")\n                self.export_str(export_str, path, DataExport.Target.FILE)\n\n        return ret\n\n    return auto_pods_export_wrapper\n</code></pre>"},{"location":"src/core/#src.core.Round","title":"Round","text":"<pre><code>Round(tour: Tournament, seq: int, stage: Stage, pairing_logic: IPairingLogic, uid: UUID | None = None, dropped: set[UUID] | None = None, disabled: set[UUID] | None = None, byes: set[UUID] | None = None, game_loss: set[UUID] | None = None)\n</code></pre> <p>               Bases: <code>IRound</code></p> <p>Represents a single round in the tournament.</p> <p>Attributes:</p> Name Type Description <code>seq</code> <code>int</code> <p>The sequence number of the round (0-indexed).</p> <code>stage</code> <code>Stage</code> <p>The stage of the round (Swiss, Top X).</p> <code>logic</code> <code>IPairingLogic</code> <p>The pairing logic used for this round.</p> <code>CACHE</code> <code>dict[UUID, Round]</code> <p>Global cache of round instances.</p> <p>Initializes a new Round instance.</p> <p>Parameters:</p> Name Type Description Default <code>tour</code> <code>Tournament</code> <p>The tournament the round belongs to.</p> required <code>seq</code> <code>int</code> <p>The sequence number of the round.</p> required <code>stage</code> <code>Stage</code> <p>The stage of the round (e.g., Swiss, Top 4).</p> required <code>pairing_logic</code> <code>IPairingLogic</code> <p>The logic used for pairing players in this round.</p> required <code>uid</code> <code>UUID | None</code> <p>Optional UUID.</p> <code>None</code> <code>dropped</code> <code>set[UUID] | None</code> <p>Optional set of dropped player UUIDs.</p> <code>None</code> <code>disabled</code> <code>set[UUID] | None</code> <p>Optional set of disabled player UUIDs.</p> <code>None</code> <code>byes</code> <code>set[UUID] | None</code> <p>Optional set of player UUIDs who have byes.</p> <code>None</code> <code>game_loss</code> <code>set[UUID] | None</code> <p>Optional set of player UUIDs who have game losses.</p> <code>None</code> Source code in <code>src/core.py</code> <pre><code>def __init__(\n    self,\n    # Required\n    tour: Tournament,\n    seq: int,\n    stage: Stage,\n    pairing_logic: IPairingLogic,\n    # Optional\n    uid: UUID | None = None,\n    dropped: set[UUID] | None = None,\n    disabled: set[UUID] | None = None,\n    byes: set[UUID] | None = None,\n    game_loss: set[UUID] | None = None,\n):\n    \"\"\"Initializes a new Round instance.\n\n    Args:\n        tour: The tournament the round belongs to.\n        seq: The sequence number of the round.\n        stage: The stage of the round (e.g., Swiss, Top 4).\n        pairing_logic: The logic used for pairing players in this round.\n        uid: Optional UUID.\n        dropped: Optional set of dropped player UUIDs.\n        disabled: Optional set of disabled player UUIDs.\n        byes: Optional set of player UUIDs who have byes.\n        game_loss: Optional set of player UUIDs who have game losses.\n    \"\"\"\n    self._tour: UUID = tour.uid\n    super().__init__(uid=uid)\n    self.tour.ROUND_CACHE[self.uid] = self\n    self.seq: int = seq\n    self.stage: Round.Stage = stage\n\n    self._logic = pairing_logic.name\n    self._byes: set[UUID] = set() if byes is None else byes\n    self._game_loss: set[UUID] = set() if game_loss is None else game_loss\n    self._dropped: set[UUID] = set() if dropped is None else dropped\n    self._disabled: set[UUID] = set() if disabled is None else disabled\n\n    self.player_locations_map: dict[UUID, Pod] = {}\n</code></pre>"},{"location":"src/core/#src.core.Round.all_players_assigned","title":"all_players_assigned  <code>property</code>","text":"<pre><code>all_players_assigned\n</code></pre> <p>Checks if all active players are assigned to pods.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if all active players are assigned to pods, False otherwise.</p>"},{"location":"src/core/#src.core.Round.done","title":"done  <code>property</code>","text":"<pre><code>done\n</code></pre> <p>Checks if the round is completed.</p> <p>A round is considered done if all pods within it have reported results (i.e., no pending pods remain).</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the round is done, False otherwise.</p>"},{"location":"src/core/#src.core.Round.seated","title":"seated  <code>property</code>","text":"<pre><code>seated: set[Player]\n</code></pre> <p>Returns the set of players who are currently assigned to pods.</p> <p>Returns:</p> Type Description <code>set[Player]</code> <p>set[Player]: A set of Player instances that are assigned to pods.</p>"},{"location":"src/core/#src.core.Round.unassigned","title":"unassigned  <code>property</code>","text":"<pre><code>unassigned: set[Player]\n</code></pre> <p>Returns the set of players who are not currently assigned to pods.</p> <p>Returns:</p> Type Description <code>set[Player]</code> <p>set[Player]: A set of Player instances that are not assigned to pods.</p>"},{"location":"src/core/#src.core.Round.advancing_players","title":"advancing_players","text":"<pre><code>advancing_players(standings) -&gt; list[Player]\n</code></pre> <p>Determines which players advance to the next round.</p> <p>This is primarily used for transitions from Swiss to Top Cut, or between Top Cut rounds.</p> <p>Parameters:</p> Name Type Description Default <code>standings</code> <p>A list of players sorted by their current standing.</p> required <p>Returns:</p> Type Description <code>list[Player]</code> <p>list[Player]: The list of players who advance. - For Swiss rounds, typically all active players return. - For Top Cut rounds, only winners (and potentially high-seeded byes) advance.</p> Source code in <code>src/core.py</code> <pre><code>def advancing_players(self, standings) -&gt; list[Player]:\n    \"\"\"Determines which players advance to the next round.\n\n    This is primarily used for transitions from Swiss to Top Cut, or between Top Cut rounds.\n\n    Args:\n       standings: A list of players sorted by their current standing.\n\n    Returns:\n        list[Player]: The list of players who advance.\n            - For Swiss rounds, typically all active players return.\n            - For Top Cut rounds, only winners (and potentially high-seeded byes) advance.\n    \"\"\"\n    # Create index map for O(1) standings lookup instead of O(n) index() calls\n    standings_index = {player: idx for idx, player in enumerate(standings)}\n\n    if self.stage == Round.Stage.SWISS:\n        return sorted(\n            self.active_players,\n            key=lambda x: standings_index.get(x, len(standings)),\n        )\n    else:\n        active_players_set = self.active_players  # Cache set lookup\n\n        # Collect players in three groups to maintain proper ordering:\n        # 1. Byes (sorted by standings)\n        # 2. Wins (sorted by standings)\n        # 3. Draws (one per draw pod, sorted by standings)\n        bye_players: list[Player] = []\n        win_players: list[Player] = []\n        draw_players: list[Player] = []\n        processed_draw_pods: set[Pod] = (\n            set()\n        )  # Track processed draw pods to avoid duplicates\n\n        for p in standings:\n            if p not in active_players_set:\n                continue\n\n            # Handle byes\n            if p in self.byes:\n                bye_players.append(p)\n                continue\n\n            # Get pod once per player\n            pod = p.pod(self)\n            if pod is None:\n                continue\n\n            # Handle WIN results\n            if pod.done and pod.result_type == Pod.EResult.WIN:\n                if p in pod.result:\n                    win_players.append(p)\n\n            # Handle DRAW results (only process once per pod)\n            elif (\n                pod.result_type == Pod.EResult.DRAW\n                and pod not in processed_draw_pods\n            ):\n                processed_draw_pods.add(pod)\n                if pod.result:\n                    # Filter to only active players in the draw result\n                    active_in_draw = [\n                        p for p in pod.result if p in active_players_set\n                    ]\n                    if active_in_draw:\n                        advancing_player = min(\n                            active_in_draw,\n                            key=lambda x: standings_index.get(x, len(standings)),\n                        )\n                        draw_players.append(advancing_player)\n\n        # Sort each group by standings and concatenate in order\n        bye_players.sort(key=lambda x: standings_index.get(x, len(standings)))\n        win_players.sort(key=lambda x: standings_index.get(x, len(standings)))\n        draw_players.sort(key=lambda x: standings_index.get(x, len(standings)))\n\n        return bye_players + win_players + draw_players\n</code></pre>"},{"location":"src/core/#src.core.Round.create_pairings","title":"create_pairings","text":"<pre><code>create_pairings() -&gt; None\n</code></pre> <p>Executes the pairing logic to assign players to pods.</p> <p>This method uses the round's <code>pairing_logic</code> to determine match-ups and assigns players to the pods created by <code>create_pods</code>.</p> Source code in <code>src/core.py</code> <pre><code>def create_pairings(self) -&gt; None:\n    \"\"\"Executes the pairing logic to assign players to pods.\n\n    This method uses the round's `pairing_logic` to determine match-ups and assigns\n    players to the pods created by `create_pods`.\n    \"\"\"\n    if self.stage != Round.Stage.SWISS:\n        standings = self.tour.get_standings(self.tour.previous_round(self))\n        self.disable_topcut(standings)\n        if self.stage in [\n            Round.Stage.TOP_7,\n            Round.Stage.TOP_10,\n            Round.Stage.TOP_13,\n            Round.Stage.TOP_16,\n            Round.Stage.TOP_40,\n        ]:\n            self.logic.advance_topcut(self, cast(list[IPlayer], standings))\n\n    self.create_pods()\n    pods = [p for p in self.pods if all([not p.done, len(p) &lt; p.cap])]\n\n    self.logic.make_pairings(self, cast(set[IPlayer], self.unassigned), pods)\n\n    if self.seq &lt; self.tour.config.n_rounds:\n        for pod in self.pods:\n            pod.auto_auto_assign_seats()\n\n    self.sort_pods()\n</code></pre>"},{"location":"src/core/#src.core.Round.create_pods","title":"create_pods","text":"<pre><code>create_pods() -&gt; None\n</code></pre> <p>Creates empty pod slots for the round.</p> <p>This method calculates the number and size of pods required based on the number of active players and the tournament configuration, then initializes these pods.</p> Source code in <code>src/core.py</code> <pre><code>def create_pods(self) -&gt; None:\n    \"\"\"Creates empty pod slots for the round.\n\n    This method calculates the number and size of pods required based on the number of\n    active players and the tournament configuration, then initializes these pods.\n    \"\"\"\n    seats_required = len(self.unassigned) - sum(\n        [pod.cap - len(pod) for pod in self.pods if not pod.done]\n    )\n    if seats_required == 0:\n        return\n    pod_sizes = self.tour.get_pod_sizes(seats_required)\n    if pod_sizes is None:\n        Log.log(\"Can not make pods.\", level=Log.Level.WARNING)\n        return None\n    start_table = len(self._pods) + 1\n    for i, size in enumerate(pod_sizes):\n        pod = Pod(self, start_table + i, cap=size)\n        self._pods.append(pod.uid)\n</code></pre>"},{"location":"src/core/#src.core.Round.disable_topcut","title":"disable_topcut","text":"<pre><code>disable_topcut(standings: list[Player])\n</code></pre> <p>Disable players who don't advance to top cut. They remain in the tournament but won't participate in top cut rounds.</p> Source code in <code>src/core.py</code> <pre><code>def disable_topcut(self, standings: list[Player]):\n    \"\"\"Disable players who don't advance to top cut.\n    They remain in the tournament but won't participate in top cut rounds.\"\"\"\n    standings = self.tour.get_standings(self.tour.previous_round(self))\n\n    # Disable players from bottom of standings until we reach top_cut size\n    for p in standings[self.stage.value : :]:\n        self.disable_player(p, set_disabled=True)\n</code></pre>"},{"location":"src/core/#src.core.Round.remove_pod","title":"remove_pod","text":"<pre><code>remove_pod(pod: Pod) -&gt; bool\n</code></pre> <p>Removes a pod from the round, clearing its assignments.</p> <p>Parameters:</p> Name Type Description Default <code>pod</code> <code>Pod</code> <p>The pod to remove.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the pod was successfully removed, False otherwise.</p> Source code in <code>src/core.py</code> <pre><code>def remove_pod(self, pod: Pod) -&gt; bool:\n    \"\"\"Removes a pod from the round, clearing its assignments.\n\n    Args:\n        pod: The pod to remove.\n\n    Returns:\n        bool: True if the pod was successfully removed, False otherwise.\n    \"\"\"\n    # if not pod.done:\n    pod.clear()\n    self._pods.remove(pod.uid)\n    return True\n</code></pre>"},{"location":"src/core/#src.core.Round.reset_pods","title":"reset_pods","text":"<pre><code>reset_pods() -&gt; bool\n</code></pre> <p>Resets all pods in the round, clearing their assignments.</p> <p>This method removes all players from all pods and clears the bye list. It is useful for resetting the round before creating new pairings.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Always returns True, as the reset is always successful.</p> Source code in <code>src/core.py</code> <pre><code>def reset_pods(self) -&gt; bool:\n    \"\"\"Resets all pods in the round, clearing their assignments.\n\n    This method removes all players from all pods and clears the bye list.\n    It is useful for resetting the round before creating new pairings.\n\n    Returns:\n        bool: Always returns True, as the reset is always successful.\n    \"\"\"\n    pods = [Pod.get(self.tour, x) for x in self._pods]\n    # if any([not pod.done for pod in pods]):\n    #    return False\n    self._byes.clear()\n    for pod in pods:\n        self.remove_pod(pod)\n    return True\n</code></pre>"},{"location":"src/core/#src.core.Round.sort_pods","title":"sort_pods","text":"<pre><code>sort_pods() -&gt; bool\n</code></pre> <p>Try to apply table preferences for players. Pod index is table number. Preserves the relative power-sorted order of non-locked pods. Prioritizes maximizing the number of satisfied preferences.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if table preferences were applied, False otherwise.</p> Source code in <code>src/core.py</code> <pre><code>def sort_pods(self) -&gt; bool:\n    \"\"\"Try to apply table preferences for players. Pod index is table number.\n    Preserves the relative power-sorted order of non-locked pods.\n    Prioritizes maximizing the number of satisfied preferences.\n\n    Returns:\n        bool: True if table preferences were applied, False otherwise.\n    \"\"\"\n    self.sort_pods_by_power()\n\n    pods = self.pods  # Expect pods to be already sorted by power\n    n = len(pods)\n    if n == 0:\n        return False\n\n    result_pods = [None] * n\n    assigned_pod_uids = set()\n    any_swapped = False\n\n    # Pass 1: Handle Locked Pods (Best effort satisfaction)\n    # We want to satisfy as many preferences as possible.\n    # Primary priority: Number of players satisfied in that pod.\n    # Secondary priority: Original power order (tie-breaker).\n\n    possibilities = []\n    for rank, pod in enumerate(pods):\n        # Aggregated preferences for players in this pod (1-indexed)\n        counts = {}\n        for p in pod.players:\n            for pref in p.table_preference:\n                target_idx = pref - 1  # Convert to 0-indexed\n                if 0 &lt;= target_idx &lt; n:\n                    counts[target_idx] = counts.get(target_idx, 0) + 1\n                else:\n                    Log.log(\n                        f\"Player {p.name} has invalid table preference: {pref}. Max table index is {n}\",\n                        level=Log.Level.WARNING,\n                    )\n\n        for target_idx, count in counts.items():\n            # Sort key: (-count, rank, target_idx)\n            # (Higher count first, then higher power first, then lower index first)\n            possibilities.append((-count, rank, pod, target_idx))\n\n    possibilities.sort()\n\n    for _, _, pod, target_idx in possibilities:\n        if pod.uid not in assigned_pod_uids and result_pods[target_idx] is None:\n            result_pods[target_idx] = pod\n            assigned_pod_uids.add(pod.uid)\n            any_swapped = True\n\n    # Pass 2: Fill gaps with remaining pods (Preserving relative power order)\n    pod_iter = iter(pods)\n    for i in range(n):\n        if result_pods[i] is None:\n            # Find the next pod that hasn't been assigned yet\n            try:\n                while True:\n                    next_pod = next(pod_iter)\n                    if next_pod.uid not in assigned_pod_uids:\n                        result_pods[i] = next_pod\n                        break\n            except StopIteration:\n                break  # Should not happen\n\n    # Update the underlying UUID list\n    self._pods[:] = [p.uid for p in result_pods if p is not None]\n\n    return any_swapped\n</code></pre>"},{"location":"src/core/#src.core.Round.sort_pods_by_power","title":"sort_pods_by_power","text":"<pre><code>sort_pods_by_power() -&gt; None\n</code></pre> <p>Sort pods by number of players and average rating to establish a power-level baseline.</p> Source code in <code>src/core.py</code> <pre><code>def sort_pods_by_power(self) -&gt; None:\n    \"\"\"Sort pods by number of players and average rating to establish a power-level baseline.\"\"\"\n    pods_sorted = sorted(\n        self.pods,\n        key=lambda x: (\n            len(x.players),\n            np.average([p.rating(self) for p in x.players]),\n        ),\n        reverse=True,\n    )\n    self._pods[:] = [pod.uid for pod in pods_sorted]\n</code></pre>"},{"location":"src/core/#src.core.SortMethod","title":"SortMethod","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for sorting methods.</p>"},{"location":"src/core/#src.core.SortOrder","title":"SortOrder","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for sorting order.</p>"},{"location":"src/core/#src.core.StandingsExport","title":"StandingsExport","text":"<pre><code>StandingsExport(fields=None, format: Format = DataExport.Format.PLAIN, dir: Union[str, None] = None)\n</code></pre> <p>               Bases: <code>DataExport</code></p> Source code in <code>src/core.py</code> <pre><code>def __init__(\n    self,\n    fields=None,\n    format: DataExport.Format = DataExport.Format.PLAIN,\n    dir: Union[str, None] = None,\n):\n    if fields is None:\n        self.fields = self.DEFAULT_FIELDS\n    else:\n        self.fields = fields\n    self.format = format\n    if dir is None:\n        self.dir = \"./logs/standings\" + self.ext[self.format]\n    else:\n        self.dir = dir\n</code></pre>"},{"location":"src/core/#src.core.StandingsExport.inflate","title":"inflate  <code>classmethod</code>","text":"<pre><code>inflate(data: dict)\n</code></pre> <p>Creates a StandingsExport instance from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The dictionary containing the configuration.</p> required <p>Returns:</p> Type Description <p>A new StandingsExport instance.</p> Source code in <code>src/core.py</code> <pre><code>@classmethod\ndef inflate(cls, data: dict):\n    \"\"\"Creates a StandingsExport instance from a dictionary.\n\n    Args:\n        data: The dictionary containing the configuration.\n\n    Returns:\n        A new StandingsExport instance.\n    \"\"\"\n    return cls(\n        [StandingsExport.Field(f) for f in data[\"fields\"]],\n        StandingsExport.Format(data[\"format\"]),\n        data[\"dir\"],\n    )\n</code></pre>"},{"location":"src/core/#src.core.StandingsExport.serialize","title":"serialize","text":"<pre><code>serialize()\n</code></pre> <p>Serializes the export configuration.</p> <p>Returns:</p> Type Description <p>A dictionary containing the serialized configuration.</p> Source code in <code>src/core.py</code> <pre><code>def serialize(self):\n    \"\"\"Serializes the export configuration.\n\n    Returns:\n        A dictionary containing the serialized configuration.\n    \"\"\"\n    return {\n        \"fields\": [f.value for f in self.fields],\n        \"format\": self.format.value,\n        \"dir\": self.dir,\n    }\n</code></pre>"},{"location":"src/core/#src.core.Tournament","title":"Tournament","text":"<pre><code>Tournament(config: Union[TournamentConfiguration, None] = None, uid: UUID | None = None)\n</code></pre> <p>               Bases: <code>ITournament</code></p> <p>Represents a tournament, managing players, rounds, and pairings.</p> <p>Attributes:</p> Name Type Description <code>CACHE</code> <code>dict[UUID, Tournament]</code> <p>Global cache of tournament instances.</p> <code>_pairing_logic_cache</code> <code>dict[str, type[IPairingLogic]]</code> <p>Cache of discovered pairing logic implementations.</p> <p>Initializes a new Tournament instance.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Union[TournamentConfiguration, None]</code> <p>The configuration object for the tournament. If None, a default configuration is used.</p> <code>None</code> <code>uid</code> <code>UUID | None</code> <p>The unique identifier for the tournament. If None, a new UUID is generated.</p> <code>None</code> Source code in <code>src/core.py</code> <pre><code>def __init__(\n    self,\n    config: Union[TournamentConfiguration, None] = None,\n    uid: UUID | None = None,\n):  # type: ignore\n    \"\"\"Initializes a new Tournament instance.\n\n    Args:\n        config: The configuration object for the tournament. If None, a default configuration is used.\n        uid: The unique identifier for the tournament. If None, a new UUID is generated.\n    \"\"\"\n    if config is None:\n        config = TournamentConfiguration()\n    super().__init__(config=config, uid=uid)\n    self._config = config\n    self.CACHE[self.uid] = self\n\n    self.PLAYER_CACHE: dict[UUID, Player] = {}\n    self.POD_CACHE: dict[UUID, Pod] = {}\n    self.ROUND_CACHE: dict[UUID, Round] = {}\n\n    self._rounds: list[UUID] = list()\n    self._players: set[UUID] = set()\n    # self._dropped: list[UUID] = list()\n    # self._disabled: list[UUID] = list()  # Players disabled from top cut (but still in tournament)\n    self._round: UUID | None = None\n</code></pre>"},{"location":"src/core/#src.core.Tournament.config","title":"config  <code>property</code> <code>writable</code>","text":"<pre><code>config: TournamentConfiguration\n</code></pre> <p>Returns the tournament configuration.</p> <p>Returns:</p> Name Type Description <code>TournamentConfiguration</code> <code>TournamentConfiguration</code> <ul> <li>The tournament configuration.</li> </ul>"},{"location":"src/core/#src.core.Tournament.draw_rate","title":"draw_rate  <code>property</code>","text":"<pre><code>draw_rate: float\n</code></pre> <p>Calculates the draw rate for the tournament.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <ul> <li>The draw rate as a float.</li> </ul>"},{"location":"src/core/#src.core.Tournament.ended_rounds","title":"ended_rounds  <code>property</code>","text":"<pre><code>ended_rounds\n</code></pre> <p>Returns the list of completed rounds in the tournament.</p> <p>Returns:</p> Type Description <p>list[Round]: - The list of completed rounds.</p>"},{"location":"src/core/#src.core.Tournament.final_swiss_round","title":"final_swiss_round  <code>property</code>","text":"<pre><code>final_swiss_round: Round | None\n</code></pre> <p>Returns the final Swiss round of the tournament.</p> <p>Returns:</p> Type Description <code>Round | None</code> <p>Round|None: - The final Swiss round if it has been played. - None if the final round has not been played yet.</p>"},{"location":"src/core/#src.core.Tournament.last_round","title":"last_round  <code>property</code>","text":"<pre><code>last_round: Round | None\n</code></pre> <p>Returns the last round of the tournament.</p> <p>Returns:</p> Type Description <code>Round | None</code> <p>Round|None: - The last round if it has been played. - None if no rounds have been played.</p>"},{"location":"src/core/#src.core.Tournament.pods","title":"pods  <code>property</code>","text":"<pre><code>pods: list[Pod] | None\n</code></pre> <p>Returns the list of pods in the current round.</p> <p>Returns:</p> Type Description <code>list[Pod] | None</code> <p>list[Pod]|None: - The list of pods if the current round has been set. - None if the current round has not been set.</p>"},{"location":"src/core/#src.core.Tournament.rounds","title":"rounds  <code>property</code> <code>writable</code>","text":"<pre><code>rounds: list[Round]\n</code></pre> <p>Returns the list of rounds in the tournament.</p> <p>Returns:</p> Type Description <code>list[Round]</code> <p>list[Round]: - The list of rounds.</p>"},{"location":"src/core/#src.core.Tournament.swiss_rounds","title":"swiss_rounds  <code>property</code>","text":"<pre><code>swiss_rounds\n</code></pre> <p>Returns the list of swiss rounds in the tournament.</p> <p>Returns:</p> Type Description <p>list[Round]: - The list of swiss rounds.</p>"},{"location":"src/core/#src.core.Tournament.add_player","title":"add_player","text":"<pre><code>add_player(*specs: Any, **player_attrs) -&gt; list[Player]\n</code></pre> <p>Adds players to the tournament.</p> <p>This method supports flexible input formats for defining players.</p> <p>Parameters:</p> Name Type Description Default <code>*specs</code> <code>Any</code> <p>Variable length argument list. Each argument can be: - A Player object. - A tuple/list of (name,), (name, uid/decklist), or (name, uid, decklist). - A dictionary containing 'name', and optionally 'uid' and 'decklist'. - A string representing the player's name.</p> <code>()</code> <code>**player_attrs</code> <p>arbitrary keyword arguments to be applied to all new players             (e.g., decklist=\"link\", uid=UUID(...)).             If only one positional argument is provided and it's a string or dict,             these attributes are merged with it.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[Player]</code> <p>list[Player]: A list of the newly created and added Player objects.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the player specification is invalid or incomplete.</p> Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef add_player(self, *specs: Any, **player_attrs) -&gt; list[Player]:\n    \"\"\"Adds players to the tournament.\n\n    This method supports flexible input formats for defining players.\n\n    Args:\n        *specs: Variable length argument list. Each argument can be:\n            - A Player object.\n            - A tuple/list of (name,), (name, uid/decklist), or (name, uid, decklist).\n            - A dictionary containing 'name', and optionally 'uid' and 'decklist'.\n            - A string representing the player's name.\n        **player_attrs: arbitrary keyword arguments to be applied to all new players\n                        (e.g., decklist=\"link\", uid=UUID(...)).\n                        If only one positional argument is provided and it's a string or dict,\n                        these attributes are merged with it.\n\n    Returns:\n        list[Player]: A list of the newly created and added Player objects.\n\n    Raises:\n        ValueError: If the player specification is invalid or incomplete.\n    \"\"\"\n\n    # Handle keyword arguments merging with a single positional spec\n    if player_attrs and len(specs) == 1 and \"name\" not in player_attrs:\n        spec = specs[0]\n        if isinstance(spec, str):\n            data = [{\"name\": spec, **player_attrs}]\n        elif isinstance(spec, dict):\n            data = [{**spec, **player_attrs}]\n        else:\n            data = list(specs) + [player_attrs]\n    else:\n        data = list(specs)\n        if player_attrs:\n            data.append(player_attrs)\n\n    # Handle backward compatibility: single positional list\n    if len(data) == 1 and isinstance(data[0], list):\n        data = data[0]\n\n    new_players = []\n    existing_names = set([p.name for p in self.players])\n    existing_uids = set([p.uid for p in self.players])\n\n    for entry in data:\n        if entry is None:\n            continue\n\n        name, uid, decklist = None, None, None\n\n        if isinstance(entry, (tuple, list)):\n            # Handle 1-tuple (name), 2-tuple (smart: name, uid/decklist), or 3-tuple (name, uid, decklist)\n            if len(entry) == 1:\n                name = entry[0]\n            elif len(entry) == 2:\n                name, second = entry\n                if isinstance(second, UUID):\n                    uid = second\n                elif isinstance(second, (str, type(None))):\n                    decklist = second\n                else:\n                    raise ValueError(\n                        f\"Unknown type for second element in player tuple: {type(second)}\"\n                    )\n            elif len(entry) == 3:\n                name, uid, decklist = entry\n            else:\n                raise ValueError(\n                    f\"Player tuple/list must have 1-3 elements, got {len(entry)}\"\n                )\n        elif isinstance(entry, dict):\n            # Handle dictionary specification\n            name = entry.get(\"name\")\n            uid = entry.get(\"uid\")\n            decklist = entry.get(\"decklist\")\n        elif isinstance(entry, str):\n            # Handle single string as name\n            name = entry\n        else:\n            raise ValueError(\n                f\"Invalid player specification type: {type(entry)}. Expected str, dict, tuple, or list.\"\n            )\n\n        if not name or not isinstance(name, str):\n            raise ValueError(\n                f\"Player name must be a non-empty string, got {type(name)}: {name}\"\n            )\n\n        if name in existing_names:\n            Log.log(\n                \"\\tPlayer {} already enlisted.\".format(name),\n                level=Log.Level.WARNING,\n            )\n            continue\n        if uid and uid in existing_uids:\n            Log.log(\n                \"\\tPlayer with UID {} already enlisted.\".format(uid),\n                level=Log.Level.WARNING,\n            )\n            continue\n\n        # Create and register the player\n        p = Player(self, name, uid, decklist)\n        self._players.add(p.uid)\n        if self._round and p.uid not in self.tour_round._players:\n            self.tour_round._players.append(p.uid)\n        new_players.append(p)\n        existing_names.add(name)\n        existing_uids.add(p.uid)\n        Log.log(\"\\tAdded player {}\".format(p.name), level=Log.Level.INFO)\n    return new_players\n</code></pre>"},{"location":"src/core/#src.core.Tournament.bench_players","title":"bench_players","text":"<pre><code>bench_players(players: Iterable[Player] | Player)\n</code></pre> <p>Removes player(s) from their current pod, effectively benching them.</p> <p>Parameters:</p> Name Type Description Default <code>players</code> <code>Iterable[Player] | Player</code> <p>The player or iterable of players to bench.</p> required Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef bench_players(self, players: Iterable[Player] | Player):\n    \"\"\"Removes player(s) from their current pod, effectively benching them.\n\n    Args:\n        players: The player or iterable of players to bench.\n    \"\"\"\n    assert self.tour_round is not None\n    if not isinstance(players, Iterable):\n        players = [players]\n    for player in players:\n        self.remove_player_from_pod(player)\n</code></pre>"},{"location":"src/core/#src.core.Tournament.create_pairings","title":"create_pairings","text":"<pre><code>create_pairings() -&gt; bool\n</code></pre> <p>Creates pairings for the current round.</p> <p>If the round has not been initialized or previous rounds are not complete, this method attempts to handle those states.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if pairings were successfully created (or were already created). False if   pairings could not be created (e.g., due to initialization failure).</p> Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef create_pairings(self) -&gt; bool:\n    \"\"\"Creates pairings for the current round.\n\n    If the round has not been initialized or previous rounds are not complete, this method attempts\n    to handle those states.\n\n    Returns:\n        bool: True if pairings were successfully created (or were already created). False if\n              pairings could not be created (e.g., due to initialization failure).\n    \"\"\"\n    if self.last_round is None or self.last_round.done:\n        ok = self.initialize_round()\n        if not ok:\n            return False\n    # self.last_round._byes.clear()\n    assert self.last_round is not None\n    if not self.last_round.all_players_assigned:\n        self.last_round.create_pairings()\n        return True\n    return False\n</code></pre>"},{"location":"src/core/#src.core.Tournament.delete_pod","title":"delete_pod","text":"<pre><code>delete_pod(pod: Pod)\n</code></pre> <p>Deletes a specified pod from the current round.</p> <p>Parameters:</p> Name Type Description Default <code>pod</code> <code>Pod</code> <p>The pod to delete.</p> required Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef delete_pod(self, pod: Pod):\n    \"\"\"Deletes a specified pod from the current round.\n\n    Args:\n        pod: The pod to delete.\n    \"\"\"\n    if self.tour_round:\n        self.tour_round.remove_pod(pod)\n</code></pre>"},{"location":"src/core/#src.core.Tournament.disable_player","title":"disable_player","text":"<pre><code>disable_player(players: list[Player] | Player, set_disabled: bool = True) -&gt; bool\n</code></pre> <p>Disables or enables players for top cut participation.</p> <p>Disabled players remain in the tournament structure but are excluded from top cut calculations and pairings.</p> <p>Parameters:</p> Name Type Description Default <code>players</code> <code>list[Player] | Player</code> <p>The player or list of players to disable/enable.</p> required <code>set_disabled</code> <code>bool</code> <p>If True, disables the player. If False, re-enables them.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Always returns True.</p> Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef disable_player(\n    self, players: list[Player] | Player, set_disabled: bool = True\n) -&gt; bool:\n    \"\"\"Disables or enables players for top cut participation.\n\n    Disabled players remain in the tournament structure but are excluded from top cut calculations and pairings.\n\n    Args:\n        players: The player or list of players to disable/enable.\n        set_disabled: If True, disables the player. If False, re-enables them.\n\n    Returns:\n        bool: Always returns True.\n    \"\"\"\n    if not isinstance(players, list):\n        players = [players]\n    for p in players:\n        self.tour_round.disable_player(p, set_disabled=set_disabled)\n    return True\n</code></pre>"},{"location":"src/core/#src.core.Tournament.discover_pairing_logic","title":"discover_pairing_logic  <code>classmethod</code>","text":"<pre><code>discover_pairing_logic() -&gt; None\n</code></pre> <p>Discover and cache all pairing logic implementations from src/pairing_logic.</p> Source code in <code>src/core.py</code> <pre><code>@classmethod\ndef discover_pairing_logic(cls) -&gt; None:\n    \"\"\"Discover and cache all pairing logic implementations from src/pairing_logic.\"\"\"\n    if cls._pairing_logic_cache:\n        return\n\n    # Get the base directory of the project\n    base_dir = Path(__file__).parent.parent\n    pairing_logic_dir = base_dir / \"src\" / \"pairing_logic\"\n\n    # Walk through all Python files in the pairing_logic directory\n    for module_info in pkgutil.iter_modules([str(pairing_logic_dir)]):\n        try:\n            # Import the module\n            module = importlib.import_module(\n                f\"src.pairing_logic.{module_info.name}\"\n            )\n\n            # Find all classes that implement IPairingLogic\n            for name, obj in module.__dict__.items():\n                if (\n                    isinstance(obj, type)\n                    and issubclass(obj, IPairingLogic)\n                    and obj != IPairingLogic\n                    and obj.IS_COMPLETE\n                ):\n                    if obj.__name__ in cls._pairing_logic_cache:\n                        raise ValueError(\n                            f\"Pairing logic {obj.__name__} already exists\"\n                        )\n                    cls._pairing_logic_cache[obj.__name__] = obj(\n                        name=f\"{obj.__name__}\"\n                    )\n        except Exception as e:\n            Log.log(\n                f\"Failed to import pairing logic module {module_info.name}: {e}\",\n                level=Log.Level.WARNING,\n            )\n</code></pre>"},{"location":"src/core/#src.core.Tournament.drop_player","title":"drop_player","text":"<pre><code>drop_player(players: list[Player] | Player) -&gt; bool\n</code></pre> <p>Drops a player or list of players from the tournament.</p> <p>Dropped players are removed from future pairings but their history remains. If a player is dropped during an active round, they might need to be resolved in the current pod first.</p> <p>Parameters:</p> Name Type Description Default <code>players</code> <code>list[Player] | Player</code> <p>The player or list of players to drop.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the drop was successful, False otherwise.</p> Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef drop_player(self, players: list[Player] | Player) -&gt; bool:\n    \"\"\"Drops a player or list of players from the tournament.\n\n    Dropped players are removed from future pairings but their history remains.\n    If a player is dropped during an active round, they might need to be resolved in the current pod first.\n\n    Args:\n        players: The player or list of players to drop.\n\n    Returns:\n        bool: True if the drop was successful, False otherwise.\n    \"\"\"\n    if not isinstance(players, list):\n        players = [players]\n    for p in players:\n        if self.tour_round and p.seated(self.tour_round):\n            if self.tour_round.done and self.tour_round != self.last_round:\n                # Log.log('Can\\'t drop {} during an active tour_round.\\nComplete the tour_round or remove player from pod first.'.format(\n                #    p.name), level=Log.Level.WARNING)\n                return False\n\n        # If player has not played yet, it can safely be deleted without being saved\n        if p.played(self.tour_round):\n            self.tour_round.drop_player(p)\n        else:\n            self._players.remove(p.uid)\n            self.tour_round._players.remove(p.uid)\n        # Remove from disabled set if they were disabled\n        self.tour_round.disable_player(p, set_disabled=False)\n    return True\n</code></pre>"},{"location":"src/core/#src.core.Tournament.export_str","title":"export_str","text":"<pre><code>export_str(data: str, var_export_param: Any, target_type: Target)\n</code></pre> <p>Exports a string of data to a specified target (file, web, discord, console).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The string data to export.</p> required <code>var_export_param</code> <code>Any</code> <p>Parameter specific to the target type (e.g., file path, log level).</p> required <code>target_type</code> <code>Target</code> <p>The target for the export (FILE, WEB, DISCORD, CONSOLE).</p> required Source code in <code>src/core.py</code> <pre><code>def export_str(\n    self,\n    data: str,\n    var_export_param: Any,\n    target_type: StandingsExport.Target,\n):\n    \"\"\"Exports a string of data to a specified target (file, web, discord, console).\n\n    Args:\n        data: The string data to export.\n        var_export_param: Parameter specific to the target type (e.g., file path, log level).\n        target_type: The target for the export (FILE, WEB, DISCORD, CONSOLE).\n    \"\"\"\n    if StandingsExport.Target.FILE == target_type:\n        if not os.path.exists(os.path.dirname(var_export_param)):\n            os.makedirs(os.path.dirname(var_export_param))\n        with open(var_export_param, \"w\", encoding=\"utf-8\") as f:\n            f.writelines(data)\n\n    if StandingsExport.Target.WEB == target_type:\n        api = os.getenv(\"EXPORT_ONLINE_API_URL\")\n        key = os.getenv(\"EXPORT_ONLINE_API_KEY\")\n        if not key or not api:\n            Log.log(\n                \"Error: EXPORT_ONLINE_API_URL or EXPORT_ONLINE_API_KEY not set in the environment variables.\"\n            )\n            return\n        tournament_id = os.getenv(\"TOURNAMENT_ID\")\n        url = f\"{api}?tournamentId={tournament_id}\"\n\n        # Send as POST request to the Express app with authentication\n        headers = {\"x-api-key\": key}\n        request_data = {\n            \"title\": \"Tournament Update\",\n            \"timestamp\": f\"{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\",\n            \"text\": data,\n            \"tournament\": self.serialize(),\n        }\n\n        thread = threading.Thread(\n            target=self.send_request, args=(url, request_data, headers)\n        )\n        thread.start()\n\n    if StandingsExport.Target.DISCORD == target_type:\n        instance = DiscordPoster.instance()\n        instance.post_message(data)\n\n    if StandingsExport.Target.CONSOLE == target_type:\n        if not isinstance(var_export_param, Log.Level):\n            var_export_param = Log.Level.INFO\n        Log.log(data, level=var_export_param)\n</code></pre>"},{"location":"src/core/#src.core.Tournament.get","title":"get  <code>classmethod</code>","text":"<pre><code>get(uid: UUID) -&gt; Tournament\n</code></pre> <p>Retrieves a tournament by its UUID.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>UUID</code> <p>The tournament UUID.</p> required <p>Returns:</p> Type Description <code>Tournament</code> <p>The tournament instance.</p> Source code in <code>src/core.py</code> <pre><code>@classmethod\ndef get(cls, uid: UUID) -&gt; Tournament:\n    \"\"\"Retrieves a tournament by its UUID.\n\n    Args:\n        uid: The tournament UUID.\n\n    Returns:\n        The tournament instance.\n    \"\"\"\n    return cls.CACHE[uid]\n</code></pre>"},{"location":"src/core/#src.core.Tournament.get_pairing_logic","title":"get_pairing_logic  <code>classmethod</code>","text":"<pre><code>get_pairing_logic(logic_name: str) -&gt; IPairingLogic\n</code></pre> <p>Get a pairing logic instance by name.</p> <p>Parameters:</p> Name Type Description Default <code>logic_name</code> <code>str</code> <p>The name of the pairing logic.</p> required <p>Returns:</p> Type Description <code>IPairingLogic</code> <p>The pairing logic class.</p> Source code in <code>src/core.py</code> <pre><code>@classmethod\ndef get_pairing_logic(cls, logic_name: str) -&gt; IPairingLogic:\n    \"\"\"Get a pairing logic instance by name.\n\n    Args:\n        logic_name: The name of the pairing logic.\n\n    Returns:\n        The pairing logic class.\n    \"\"\"\n    cls.discover_pairing_logic()\n\n    if logic_name not in cls._pairing_logic_cache:\n        raise ValueError(f\"Unknown pairing logic: {logic_name}\")\n\n    return cls._pairing_logic_cache[logic_name]\n</code></pre>"},{"location":"src/core/#src.core.Tournament.get_pod_sizes","title":"get_pod_sizes","text":"<pre><code>get_pod_sizes(n) -&gt; list[int] | None\n</code></pre> <p>Determines possible pod sizes for a given number of players based on configuration.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <p>The number of players.</p> required <p>Returns:</p> Type Description <code>list[int] | None</code> <p>A list of integers representing the sizes of the pods, or None if no valid combination is found.</p> Source code in <code>src/core.py</code> <pre><code>def get_pod_sizes(self, n) -&gt; list[int] | None:\n    \"\"\"Determines possible pod sizes for a given number of players based on configuration.\n\n    Args:\n        n: The number of players.\n\n    Returns:\n        A list of integers representing the sizes of the pods, or None if no valid combination is found.\n    \"\"\"\n    # Stack to store (remaining_players, current_pod_size_index, current_solution)\n    stack = [(n, 0, [])]\n\n    while stack:\n        remaining, pod_size_idx, current_solution = stack.pop()\n\n        # If we've processed all pod sizes, continue to next iteration\n        if pod_size_idx &gt;= len(self.config.pod_sizes):\n            continue\n\n        pod_size = self.config.pod_sizes[pod_size_idx]\n        rem = remaining - pod_size\n\n        # Skip if this pod size would exceed remaining players\n        if rem &lt; 0:\n            stack.append((remaining, pod_size_idx + 1, current_solution))\n            continue\n\n        # If this pod size exactly matches remaining players, we found a solution\n        if rem == 0:\n            return current_solution + [pod_size]\n\n        # Handle case where remaining players is less than minimum pod size\n        if rem &lt; self.config.min_pod_size:\n            if self.config.allow_bye and rem &lt;= self.config.max_byes:\n                return current_solution + [pod_size]\n            elif pod_size == self.config.pod_sizes[-1]:\n                continue\n            else:\n                stack.append((remaining, pod_size_idx + 1, current_solution))\n                continue\n\n        # If remaining players is valid, try this pod size and continue with remaining players\n        if rem &gt;= self.config.min_pod_size:\n            stack.append((remaining, pod_size_idx + 1, current_solution))\n            stack.append((rem, 0, current_solution + [pod_size]))\n\n    return None\n</code></pre>"},{"location":"src/core/#src.core.Tournament.get_pods_str","title":"get_pods_str","text":"<pre><code>get_pods_str() -&gt; str\n</code></pre> <p>Generates a string representation of the current round's pods.</p> <p>Returns:</p> Type Description <code>str</code> <p>A formatted string showing the pods and players, including byes if applicable.</p> Source code in <code>src/core.py</code> <pre><code>def get_pods_str(self) -&gt; str:\n    \"\"\"Generates a string representation of the current round's pods.\n\n    Returns:\n        A formatted string showing the pods and players, including byes if applicable.\n    \"\"\"\n    if not self.tour_round:\n        return \"\"\n    standings = self.get_standings(self.tour_round)\n    export_str = \"\\n\\n\".join(\n        [\n            pod.__repr__(TournamentContext(self, self.tour_round, standings))\n            for pod in self.tour_round.pods\n        ]\n    )\n\n    if self.config.allow_bye and self.tour_round.unassigned:\n        export_str += \"\\n\\nByes:\\n\" + \"\\n:\".join(\n            [\n                \"\\t{}\\t| pts: {}\".format(p.name, p.rating(self.tour_round) or \"0\")\n                for p in self.tour_round.unassigned\n            ]\n        )\n    return export_str\n</code></pre>"},{"location":"src/core/#src.core.Tournament.get_standings","title":"get_standings","text":"<pre><code>get_standings(tour_round: Round | None = None) -&gt; list[Player]\n</code></pre> <p>Calculates and retrieves the standings for a specific round.</p> <p>Use this instead of accessing the players list directly, as this method ensures players are sorted according to the tournament's ranking configuration.</p> <p>Parameters:</p> Name Type Description Default <code>tour_round</code> <code>Round | None</code> <p>The round for which to calculate standings.         If None, uses the current round.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Player]</code> <p>list[Player]: A list of players sorted by their current standing.</p> Source code in <code>src/core.py</code> <pre><code>@override\ndef get_standings(self, tour_round: Round | None = None) -&gt; list[Player]:\n    \"\"\"Calculates and retrieves the standings for a specific round.\n\n    Use this instead of accessing the players list directly, as this method ensures\n    players are sorted according to the tournament's ranking configuration.\n\n    Args:\n        tour_round: The round for which to calculate standings.\n                    If None, uses the current round.\n\n    Returns:\n        list[Player]: A list of players sorted by their current standing.\n    \"\"\"\n    method = Player.SORT_METHOD\n    order = Player.SORT_ORDER\n    Player.SORT_METHOD = SortMethod.RANK\n    Player.SORT_ORDER = SortOrder.ASCENDING\n    playoffs = False\n    if tour_round is None:\n        tour_round = self.tour_round\n    if tour_round.stage == Round.Stage.SWISS:\n        standings = sorted(\n            self.players,\n            key=lambda x: self.config.ranking(x, tour_round),\n            reverse=True,\n        )\n    else:\n        final_swiss = self.final_swiss_round\n        assert final_swiss is not None\n        playoff_stage = tour_round.seq - final_swiss.seq - 1\n\n        if playoff_stage &gt; 0:\n            # TODO: take the standings of previous playoff round and modify them to current results\n            previous_round = self.previous_round(tour_round)\n            assert previous_round is not None\n            standings = self.get_standings(previous_round)\n            advancing_players = tour_round.advancing_players(standings)\n            non_advancing = [p for p in standings if p not in advancing_players]\n            standings = advancing_players + non_advancing\n            pass\n        else:\n            swiss_standings = self.get_standings(final_swiss)\n            advancing_players = tour_round.advancing_players(swiss_standings)\n            non_advancing = [\n                p for p in swiss_standings if p not in advancing_players\n            ]\n\n            # Sort non-advancing players: draws rank above losses, then by original standings\n            standings_index = {\n                player: idx for idx, player in enumerate(swiss_standings)\n            }\n            non_advancing.sort(\n                key=lambda x: (\n                    0\n                    if tour_round and x.result(tour_round) == Player.EResult.DRAW\n                    else 1,  # Draws first (0), losses second (1)\n                    standings_index.get(\n                        x, len(swiss_standings)\n                    ),  # Then by original standings position\n                )\n            )\n\n            standings = advancing_players + non_advancing\n            pass\n\n        # TODO: Implement playoff standings\n        pass\n\n    Player.SORT_METHOD = method\n    Player.SORT_ORDER = order\n    return standings\n</code></pre>"},{"location":"src/core/#src.core.Tournament.get_standings_str","title":"get_standings_str","text":"<pre><code>get_standings_str(fields: list[Field] = StandingsExport.DEFAULT_FIELDS, style: Format = StandingsExport.Format.PLAIN, tour_round: Round | None = None, standings: list[Player] | None = None) -&gt; str\n</code></pre> <p>Generates a formatted string of the tournament standings.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>list[Field]</code> <p>A list of StandingsExport.Field to include in the standings.</p> <code>DEFAULT_FIELDS</code> <code>style</code> <code>Format</code> <p>The desired output format (e.g., PLAIN, CSV, DISCORD, JSON).</p> <code>PLAIN</code> <code>tour_round</code> <code>Round | None</code> <p>The round for which to generate standings. Defaults to the current round.</p> <code>None</code> <code>standings</code> <code>list[Player] | None</code> <p>Pre-calculated standings. If None, standings will be calculated.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A string containing the formatted standings.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid style is provided.</p> Source code in <code>src/core.py</code> <pre><code>def get_standings_str(\n    self,\n    fields: list[StandingsExport.Field] = StandingsExport.DEFAULT_FIELDS,\n    style: StandingsExport.Format = StandingsExport.Format.PLAIN,\n    tour_round: Round | None = None,\n    standings: list[Player] | None = None,\n) -&gt; str:\n    \"\"\"Generates a formatted string of the tournament standings.\n\n    Args:\n        fields: A list of StandingsExport.Field to include in the standings.\n        style: The desired output format (e.g., PLAIN, CSV, DISCORD, JSON).\n        tour_round: The round for which to generate standings. Defaults to the current round.\n        standings: Pre-calculated standings. If None, standings will be calculated.\n\n    Returns:\n        A string containing the formatted standings.\n\n    Raises:\n        ValueError: If an invalid style is provided.\n    \"\"\"\n    # raise DeprecationWarning(\"get_standings_str is deprecated. Use get_standings instead.\")\n    if tour_round is None:\n        tour_round = self.tour_round\n    if standings is None:\n        standings = self.get_standings(tour_round)\n\n    # Create context with all available data\n    context = TournamentContext(\n        tour=self,\n        tour_round=tour_round,\n        standings=standings,\n    )\n\n    lines = [[StandingsExport.info[f].name for f in fields]]\n    lines += [\n        [\n            (StandingsExport.info[f].format).format(\n                StandingsExport.info[f].get(p, context)\n                if StandingsExport.info[f].denom is None\n                else StandingsExport.info[f].get(p, context)\n                * StandingsExport.info[f].denom\n            )\n            for f in fields\n        ]\n        for p in standings\n    ]\n    if style == StandingsExport.Format.PLAIN:\n        col_len = [0] * len(fields)\n        for col in range(len(fields)):\n            for line in lines:\n                if len(line[col]) &gt; col_len[col]:\n                    col_len[col] = len(line[col])\n        for line in lines:\n            for col in range(len(fields)):\n                line[col] = line[col].ljust(col_len[col])\n        # add new line at index 1\n        lines.insert(1, [\"-\" * width for width in col_len])\n        lines = \"\\n\".join([\" | \".join(line) for line in lines])\n        return lines\n\n        # Log.log('Log saved: {}.'.format(\n        #    fdir), level=Log.Level.INFO)\n    elif style == StandingsExport.Format.CSV:\n        Log.log(\n            \"Log not saved - CSV not implemented.\".format(fdir),\n            level=Log.Level.WARNING,\n        )\n    elif style == StandingsExport.Format.DISCORD:\n        Log.log(\n            \"Log not saved - DISCORD not implemented.\".format(fdir),\n            level=Log.Level.WARNING,\n        )\n    elif style == StandingsExport.Format.JSON:\n        Log.log(\n            \"Log not saved - JSON not implemented.\".format(fdir),\n            level=Log.Level.WARNING,\n        )\n\n    raise ValueError(\"Invalid style: {}\".format(style))\n</code></pre>"},{"location":"src/core/#src.core.Tournament.inflate","title":"inflate  <code>classmethod</code>","text":"<pre><code>inflate(data: dict[str, Any]) -&gt; Tournament\n</code></pre> <p>Creates a Tournament instance from serialized data.</p> <p>This method reconstructs the entire tournament state, including players, rounds, and pods, linking them back together using their UUIDs.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>A dictionary containing the serialized tournament data (as produced by <code>serialize</code>).</p> required <p>Returns:</p> Name Type Description <code>Tournament</code> <code>Tournament</code> <p>The reconstructed Tournament instance.</p> Source code in <code>src/core.py</code> <pre><code>@classmethod\ndef inflate(cls, data: dict[str, Any]) -&gt; Tournament:\n    \"\"\"Creates a Tournament instance from serialized data.\n\n    This method reconstructs the entire tournament state, including players, rounds, and pods,\n    linking them back together using their UUIDs.\n\n    Args:\n        data: A dictionary containing the serialized tournament data (as produced by `serialize`).\n\n    Returns:\n        Tournament: The reconstructed Tournament instance.\n    \"\"\"\n    config = TournamentConfiguration.inflate(data[\"config\"])\n    tour_uid = UUID(data[\"uid\"])\n    if tour_uid in Tournament.CACHE:\n        tour = Tournament.CACHE[tour_uid]\n    else:\n        tour = cls(config, tour_uid)\n    tour._players = {UUID(d_player[\"uid\"]) for d_player in data[\"players\"]}\n    # tour._dropped = [UUID(d_player['uid']) for d_player in data['dropped']]\n    # tour._disabled = [UUID(d_player['uid']) for d_player in data['disabled']]\n    # tour._players.extend(tour._dropped)\n    # tour._players.extend(tour._disabled)\n    # Load disabled players (backward compatible: may not exist in old saves)\n    # if 'disabled' in data:\n    #    tour._disabled = {UUID(uid) for uid in data['disabled']}\n    for d_player in data[\"players\"]:\n        Player.inflate(tour, d_player)\n    # for d_player in data['dropped']:\n    #    Player.inflate(tour, d_player)\n    tour._rounds = [UUID(d_round[\"uid\"]) for d_round in data[\"rounds\"]]\n    for _, d_round in tqdm(enumerate(data[\"rounds\"]), desc=\"Inflating rounds\"):\n        r = Round.inflate(tour, d_round)\n        tour._round = r.uid\n    return tour\n</code></pre>"},{"location":"src/core/#src.core.Tournament.initialize_round","title":"initialize_round","text":"<pre><code>initialize_round() -&gt; bool\n</code></pre> <p>Initializes a new round in the tournament.</p> <p>This method determines the appropriate stage (Swiss, Top Cut) and pairing logic based on the tournament configuration and current progress. It does not create pairings, only sets up the round structure.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if a new ro  und was successfully initialized. False if a round is already in progress,   the maximum number of rounds has been reached, or the tournament is completed.</p> Source code in <code>src/core.py</code> <pre><code>def initialize_round(self) -&gt; bool:\n    \"\"\"Initializes a new round in the tournament.\n\n    This method determines the appropriate stage (Swiss, Top Cut) and pairing logic based on the\n    tournament configuration and current progress. It does not create pairings, only sets up the round structure.\n\n    Returns:\n        bool: True if a new ro  und was successfully initialized. False if a round is already in progress,\n              the maximum number of rounds has been reached, or the tournament is completed.\n    \"\"\"\n    if self._round is not None and not self.tour_round.done:\n        return False\n    seq = len(self.rounds)\n    stage = Round.Stage.SWISS\n    logic = None\n    if seq &gt;= self.config.n_rounds and self.last_round:\n        if self.config.top_cut == TournamentConfiguration.TopCut.NONE:\n            Log.log(\"Maximum number of rounds reached.\", level=Log.Level.WARNING)\n            return False\n        if self.config.top_cut == TournamentConfiguration.TopCut.TOP_4:\n            if self.last_round.stage == Round.Stage.SWISS:\n                logic = self.get_pairing_logic(\"PairingTop4\")\n                stage = Round.Stage.TOP_4\n            else:\n                Log.log(\"Tournament completed.\")\n                return False\n        elif self.config.top_cut == TournamentConfiguration.TopCut.TOP_7:\n            if self.last_round.stage == Round.Stage.SWISS:\n                stage = Round.Stage.TOP_7\n                logic = self.get_pairing_logic(\"PairingTop7\")\n            elif self.last_round.stage == Round.Stage.TOP_7:\n                stage = Round.Stage.TOP_4\n                logic = self.get_pairing_logic(\"PairingTop4\")\n            else:\n                Log.log(\"Tournament completed.\")\n                return False\n        elif self.config.top_cut == TournamentConfiguration.TopCut.TOP_10:\n            if self.last_round.stage == Round.Stage.SWISS:\n                stage = Round.Stage.TOP_10\n                logic = self.get_pairing_logic(\"PairingTop10\")\n            elif self.last_round.stage == Round.Stage.TOP_10:\n                stage = Round.Stage.TOP_4\n                logic = self.get_pairing_logic(\"PairingTop4\")\n            else:\n                Log.log(\"Tournament completed.\")\n                return False\n        elif self.config.top_cut == TournamentConfiguration.TopCut.TOP_13:\n            if self.last_round.stage == Round.Stage.SWISS:\n                stage = Round.Stage.TOP_13\n                logic = self.get_pairing_logic(\"PairingTop13\")\n            elif self.last_round.stage == Round.Stage.TOP_13:\n                stage = Round.Stage.TOP_4\n                logic = self.get_pairing_logic(\"PairingTop4\")\n            else:\n                Log.log(\"Tournament completed.\")\n                return False\n        elif self.config.top_cut == TournamentConfiguration.TopCut.TOP_16:\n            if self.last_round.stage == Round.Stage.SWISS:\n                stage = Round.Stage.TOP_16\n                logic = self.get_pairing_logic(\"PairingTop16\")\n            elif self.last_round.stage == Round.Stage.TOP_16:\n                stage = Round.Stage.TOP_4\n                logic = self.get_pairing_logic(\"PairingTop4\")\n            else:\n                Log.log(\"Tournament completed.\")\n                return False\n        elif self.config.top_cut == TournamentConfiguration.TopCut.TOP_40:\n            if self.last_round.stage == Round.Stage.SWISS:\n                stage = Round.Stage.TOP_40\n                logic = self.get_pairing_logic(\"PairingTop40\")\n            elif self.last_round.stage == Round.Stage.TOP_40:\n                stage = Round.Stage.TOP_16\n                logic = self.get_pairing_logic(\"PairingTop16\")\n            elif self.last_round.stage == Round.Stage.TOP_16:\n                stage = Round.Stage.TOP_4\n                logic = self.get_pairing_logic(\"PairingTop4\")\n            else:\n                Log.log(\"Tournament completed.\")\n                return False\n        else:\n            raise ValueError(f\"Unknown top cut: {self.config.top_cut}\")\n    else:\n        if seq == 0:\n            logic = self.get_pairing_logic(\"PairingRandom\")\n        elif seq == 1 and self.config.snake_pods:\n            logic = self.get_pairing_logic(\"PairingSnake\")\n        else:\n            logic = self.get_pairing_logic(\"PairingDefault\")\n\n    if not logic:\n        Log.log(\"No pairing logic found.\", level=Log.Level.ERROR)\n        return False\n    elif not stage:\n        Log.log(\"No stage found.\", level=Log.Level.ERROR)\n        return False\n    new_round = Round(\n        self,\n        len(self.rounds),\n        stage,\n        logic,\n        dropped=self.tour_round._dropped if self._round else set(),\n        disabled=self.tour_round._disabled if self._round else set(),\n    )\n    self._rounds.append(new_round.uid)\n    self.tour_round = new_round\n    return True\n</code></pre>"},{"location":"src/core/#src.core.Tournament.manual_pod","title":"manual_pod","text":"<pre><code>manual_pod(players: list[Player])\n</code></pre> <p>Creates a manual pod with the specified players.</p> <p>Parameters:</p> Name Type Description Default <code>players</code> <code>list[Player]</code> <p>A list of players to include in the manual pod.</p> required Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef manual_pod(self, players: list[Player]):\n    \"\"\"Creates a manual pod with the specified players.\n\n    Args:\n        players: A list of players to include in the manual pod.\n    \"\"\"\n    if self.tour_round is None or self.tour_round.done:\n        if not self.new_round():\n            return\n    assert isinstance(self.tour_round, Round)\n    cap = min(self.config.max_pod_size, len(self.tour_round.unassigned))\n    pod = Pod(self.tour_round, len(self.tour_round.pods), cap=cap)\n    self.tour_round._pods.append(pod.uid)\n\n    for player in players:\n        pod.add_player(player)\n    self.tour_round.pods.append(pod)\n</code></pre>"},{"location":"src/core/#src.core.Tournament.move_player_to_pod","title":"move_player_to_pod","text":"<pre><code>move_player_to_pod(pod: Pod, players: list[Player] | Player, manual=False)\n</code></pre> <p>Moves a player or list of players to a specified pod.</p> <p>Parameters:</p> Name Type Description Default <code>pod</code> <code>Pod</code> <p>The target pod.</p> required <code>players</code> <code>list[Player] | Player</code> <p>The player or list of players to move.</p> required <code>manual</code> <p>If True, allows adding players even if the pod is full.</p> <code>False</code> Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef move_player_to_pod(\n    self, pod: Pod, players: list[Player] | Player, manual=False\n):\n    \"\"\"Moves a player or list of players to a specified pod.\n\n    Args:\n        pod: The target pod.\n        players: The player or list of players to move.\n        manual: If True, allows adding players even if the pod is full.\n    \"\"\"\n    if not isinstance(players, list):\n        players = [players]\n    for player in players:\n        if player.pod(self.tour_round) == pod:\n            continue\n            # player.pod(self.tour_round).remove_player(player)\n            # Log.log('Removed player {} from {}.'.format(\n            #    player.name, old_pod), level=Log.Level.INFO)\n        if ok := pod.add_player(player, manual=manual):\n            pass\n</code></pre>"},{"location":"src/core/#src.core.Tournament.new_round","title":"new_round","text":"<pre><code>new_round() -&gt; bool\n</code></pre> <p>Starts a new round.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if a new round was successfully started, False otherwise.</p> Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef new_round(self) -&gt; bool:\n    \"\"\"Starts a new round.\n\n    Returns:\n        True if a new round was successfully started, False otherwise.\n    \"\"\"\n    if not self.last_round or self.last_round.done:\n        return self.initialize_round()\n    return False\n</code></pre>"},{"location":"src/core/#src.core.Tournament.previous_round","title":"previous_round","text":"<pre><code>previous_round(tour_round: Round | None = None) -&gt; Round | None\n</code></pre> <p>Returns the previous round of the tournament.</p> <p>Parameters:</p> Name Type Description Default <code>tour_round</code> <code>Round | None</code> <p>The current round.</p> <code>None</code> <p>Returns:</p> Type Description <code>Round | None</code> <p>Round|None: - The previous round if it exists. - None if the current round is the first round.</p> Source code in <code>src/core.py</code> <pre><code>def previous_round(self, tour_round: Round | None = None) -&gt; Round | None:\n    \"\"\"\n    Returns the previous round of the tournament.\n\n    Args:\n        tour_round: The current round.\n\n    Returns:\n        Round|None:\n            - The previous round if it exists.\n            - None if the current round is the first round.\n    \"\"\"\n    if tour_round is None:\n        tour_round = self.tour_round\n    return (\n        self.rounds[self.rounds.index(tour_round) - 1]\n        if self.rounds.index(tour_round) &gt; 0\n        else None\n    )\n</code></pre>"},{"location":"src/core/#src.core.Tournament.random_results","title":"random_results","text":"<pre><code>random_results()\n</code></pre> <p>Generates random results for all incomplete pods in the current round.</p> Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef random_results(self):\n    \"\"\"Generates random results for all incomplete pods in the current round.\"\"\"\n    if not self.tour_round:\n        # Log.log(\n        #    'A tour_round is not in progress.\\nCreate pods first!',\n        #    level=Log.Level.ERROR\n        # )\n        return\n    if self.tour_round.pods:\n        draw_rate = 1 - sum(self.config.global_wr_seats)\n        # for each pod\n        # generate a random result based on global_winrates_by_seat\n        # each value corresponds to the pointrate of the player in that seat\n        # the sum of percentages is less than 1, so there is a chance of a draw (1-sum(winrates))\n\n        for pod in [x for x in self.tour_round.pods if not x.done]:\n            # generate a random result\n            result = random.random()\n            rates = np.array(\n                self.config.global_wr_seats[0 : len(pod.players)] + [draw_rate]\n            )\n            rates = np.cumsum(rates / sum(rates))\n            draw = result &gt; rates[-2]\n            if not draw:\n                win = np.argmax([result &lt; x for x in rates])\n                # Log.log('won \"{}\"'.format(pod.players[win].name))\n                self.tour_round.set_result(pod.players[win], Player.EResult.WIN)\n                # player = random.sample(pod.players, 1)[0]\n                # Log.log('won \"{}\"'.format(player.name))\n                # self.tour_round.won([player])\n            else:\n                players = pod.players\n                # Log.log('draw {}'.format(\n                #    ' '.join(['\"{}\"'.format(p.name) for p in players])))\n                for p in players:\n                    self.tour_round.set_result(p, Player.EResult.DRAW)\n            pass\n    pass\n</code></pre>"},{"location":"src/core/#src.core.Tournament.rating","title":"rating","text":"<pre><code>rating(player: Player, tour_round: Round) -&gt; float\n</code></pre> <p>Calculate the rating of a player for a given round. The rating is the sum of the points for the player in the Swiss rounds up to and including the given round. If the round is not a Swiss round, the rating is the sum of the points for the player in the last Swiss round.</p> <p>Parameters:</p> Name Type Description Default <code>player</code> <code>Player</code> <p>The player for whom to calculate the rating.</p> required <code>tour_round</code> <code>Round</code> <p>The round up to which to calculate the rating.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The player's rating as a float.</p> Source code in <code>src/core.py</code> <pre><code>def rating(self, player: Player, tour_round: Round) -&gt; float:\n    \"\"\"\n    Calculate the rating of a player for a given round.\n    The rating is the sum of the points for the player in the Swiss rounds up to and including the given round.\n    If the round is not a Swiss round, the rating is the sum of the points for the player in the last Swiss round.\n\n    Args:\n        player: The player for whom to calculate the rating.\n        tour_round: The round up to which to calculate the rating.\n\n    Returns:\n        The player's rating as a float.\n    \"\"\"\n    points = 0\n    for i, i_tour_round in enumerate(self.rounds):\n        if i_tour_round.stage != Round.Stage.SWISS:\n            break\n        round_result = player.result(i_tour_round)\n        if round_result == Player.EResult.WIN:\n            points += self.config.win_points\n        elif round_result == Player.EResult.DRAW:\n            points += self.config.draw_points\n        elif round_result == Player.EResult.BYE:\n            points += self.config.bye_points\n        if i_tour_round == tour_round:\n            break\n    return points\n</code></pre>"},{"location":"src/core/#src.core.Tournament.remove_player_from_pod","title":"remove_player_from_pod","text":"<pre><code>remove_player_from_pod(player: Player)\n</code></pre> <p>Removes a player from their current pod.</p> <p>Parameters:</p> Name Type Description Default <code>player</code> <code>Player</code> <p>The player to remove.</p> required Source code in <code>src/core.py</code> <pre><code>def remove_player_from_pod(self, player: Player):\n    \"\"\"Removes a player from their current pod.\n\n    Args:\n        player: The player to remove.\n    \"\"\"\n    assert self.tour_round is not None\n    pod = player.pod(self.tour_round)\n    if pod:\n        pod.remove_player(player)\n</code></pre>"},{"location":"src/core/#src.core.Tournament.rename_player","title":"rename_player","text":"<pre><code>rename_player(player, new_name)\n</code></pre> <p>Renames a player in the tournament.</p> <p>This updates the player's name across all historical records in the tournament (pods, rounds).</p> <p>Parameters:</p> Name Type Description Default <code>player</code> <p>The player object to rename.</p> required <code>new_name</code> <p>The new name for the player.</p> required Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef rename_player(self, player, new_name):\n    \"\"\"Renames a player in the tournament.\n\n    This updates the player's name across all historical records in the tournament (pods, rounds).\n\n    Args:\n        player: The player object to rename.\n        new_name: The new name for the player.\n    \"\"\"\n    if player.name == new_name:\n        return\n    if new_name in [p.name for p in self.active_players]:\n        Log.log(\n            \"\\tPlayer {} already enlisted.\".format(new_name),\n            level=Log.Level.WARNING,\n        )\n        return\n    if new_name:\n        player.name = new_name\n        for tour_round in self.rounds:\n            for pod in tour_round.pods:\n                for p in pod.players:\n                    if p.name == player.name:\n                        p.name = new_name\n        Log.log(\n            \"\\tRenamed player {} to {}\".format(player.name, new_name),\n            level=Log.Level.INFO,\n        )\n</code></pre>"},{"location":"src/core/#src.core.Tournament.report_draw","title":"report_draw","text":"<pre><code>report_draw(players: list[Player] | Player)\n</code></pre> <p>Reports a draw for the specified player(s) in the current round.</p> <p>Parameters:</p> Name Type Description Default <code>players</code> <code>list[Player] | Player</code> <p>The player or list of players who drew.</p> required Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef report_draw(self, players: list[Player] | Player):\n    \"\"\"Reports a draw for the specified player(s) in the current round.\n\n    Args:\n        players: The player or list of players who drew.\n    \"\"\"\n    if self.tour_round:\n        if not isinstance(players, list):\n            players = [players]\n        for p in players:\n            self.tour_round.set_result(p, Player.EResult.DRAW)\n</code></pre>"},{"location":"src/core/#src.core.Tournament.report_win","title":"report_win","text":"<pre><code>report_win(players: list[Player] | Player)\n</code></pre> <p>Reports a win for the specified player(s) in the current round.</p> <p>Parameters:</p> Name Type Description Default <code>players</code> <code>list[Player] | Player</code> <p>The player or list of players who won.</p> required Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef report_win(self, players: list[Player] | Player):\n    \"\"\"Reports a win for the specified player(s) in the current round.\n\n    Args:\n        players: The player or list of players who won.\n    \"\"\"\n    if self.tour_round:\n        if not isinstance(players, list):\n            players = [players]\n        for p in players:\n            self.tour_round.set_result(p, Player.EResult.WIN)\n</code></pre>"},{"location":"src/core/#src.core.Tournament.reset_pods","title":"reset_pods","text":"<pre><code>reset_pods() -&gt; bool\n</code></pre> <p>Resets the pods for the current round.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if pods were reset, False otherwise.</p> Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef reset_pods(self) -&gt; bool:\n    \"\"\"Resets the pods for the current round.\n\n    Returns:\n        True if pods were reset, False otherwise.\n    \"\"\"\n    if not self.tour_round:\n        return False\n    if not self.tour_round.done:\n        if not self.tour_round.reset_pods():\n            return False\n        return True\n    return False\n</code></pre>"},{"location":"src/core/#src.core.Tournament.send_request","title":"send_request  <code>staticmethod</code>","text":"<pre><code>send_request(api, data, headers)\n</code></pre> <p>Sends a POST request to a specified API endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>api</code> <p>The API endpoint URL.</p> required <code>data</code> <p>The JSON data to send.</p> required <code>headers</code> <p>A dictionary of HTTP headers.</p> required Source code in <code>src/core.py</code> <pre><code>@staticmethod\ndef send_request(api, data, headers):\n    \"\"\"Sends a POST request to a specified API endpoint.\n\n    Args:\n        api: The API endpoint URL.\n        data: The JSON data to send.\n        headers: A dictionary of HTTP headers.\n    \"\"\"\n    try:\n        response = requests.post(api, json=data, headers=headers, timeout=10)\n        if response.status_code == 200:\n            Log.log(\"Data successfully sent to the server!\")\n        else:\n            Log.log(f\"Failed to send data. Status code: {response.status_code}\")\n    except Exception as e:\n        Log.log(f\"Error sending data: {e}\", level=Log.Level.ERROR)\n</code></pre>"},{"location":"src/core/#src.core.Tournament.serialize","title":"serialize","text":"<pre><code>serialize() -&gt; dict[str, Any]\n</code></pre> <p>Serializes the tournament state to a JSON-compatible dictionary.</p> <p>The serialization includes: - specific tournament configuration - list of players (including their state) - list of pods (including their state) - list of rounds (including pairings and results)</p> <p>All objects are cross-referenced by their unique IDs to maintain integrity upon restoration.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, Any]</code> <p>A dictionary representing the serialized tournament data.</p> Source code in <code>src/core.py</code> <pre><code>def serialize(self) -&gt; dict[str, Any]:\n    \"\"\"Serializes the tournament state to a JSON-compatible dictionary.\n\n    The serialization includes:\n    - specific tournament configuration\n    - list of players (including their state)\n    - list of pods (including their state)\n    - list of rounds (including pairings and results)\n\n    All objects are cross-referenced by their unique IDs to maintain integrity upon restoration.\n\n    Returns:\n        dict: A dictionary representing the serialized tournament data.\n    \"\"\"\n\n    data: dict[str, Any] = {}\n    data[\"uid\"] = str(self.uid)\n    data[\"config\"] = self.config.serialize()\n    data[\"players\"] = list(p.serialize() for p in self.players)\n    # data['dropped'] = [p.serialize() for p in self.dropped_players]\n    # data['disabled'] = [str(p.uid) for p in self.disabled_players]\n    data[\"rounds\"] = [r.serialize() for r in self.rounds]\n    return data\n</code></pre>"},{"location":"src/core/#src.core.Tournament.toggle_bye","title":"toggle_bye","text":"<pre><code>toggle_bye(players: Iterable[Player] | Player)\n</code></pre> <p>Toggles the bye status for player(s).</p> <p>If a player is assigned a bye, they are removed from their pod and marked as having a bye. If they already have a bye, it is removed.</p> <p>Parameters:</p> Name Type Description Default <code>players</code> <code>Iterable[Player] | Player</code> <p>The player or iterable of players to toggle bye for.</p> required Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef toggle_bye(self, players: Iterable[Player] | Player):\n    \"\"\"Toggles the bye status for player(s).\n\n    If a player is assigned a bye, they are removed from their pod and marked as having a bye.\n    If they already have a bye, it is removed.\n\n    Args:\n        players: The player or iterable of players to toggle bye for.\n    \"\"\"\n    if not isinstance(players, Iterable):\n        players = [players]\n    for player in players:\n        if player.uid in self.tour_round._byes:\n            self.tour_round._byes.remove(player.uid)\n        else:\n            if player.pod(self.tour_round) is not None:\n                self.remove_player_from_pod(player)\n            self.tour_round.set_result(player, Player.EResult.BYE)\n</code></pre>"},{"location":"src/core/#src.core.Tournament.toggle_game_loss","title":"toggle_game_loss","text":"<pre><code>toggle_game_loss(players: Iterable[Player] | Player)\n</code></pre> <p>Toggles the game loss status for player(s).</p> <p>If a player is assigned a game loss, they are removed from their pod and marked as having lost. If they already have a game loss, it is removed.</p> <p>Parameters:</p> Name Type Description Default <code>players</code> <code>Iterable[Player] | Player</code> <p>The player or iterable of players to toggle game loss for.</p> required Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef toggle_game_loss(self, players: Iterable[Player] | Player):\n    \"\"\"Toggles the game loss status for player(s).\n\n    If a player is assigned a game loss, they are removed from their pod and marked as having lost.\n    If they already have a game loss, it is removed.\n\n    Args:\n        players: The player or iterable of players to toggle game loss for.\n    \"\"\"\n    if not isinstance(players, Iterable):\n        players = [players]\n\n    for player in players:\n        if player.uid in self.tour_round._game_loss:\n            self.tour_round._game_loss.remove(player.uid)\n        else:\n            # if player.pod(self.tour_round) is not None:\n            #    self.remove_player_from_pod(player)\n            player.set_result(self.tour_round, Player.EResult.LOSS)\n</code></pre>"},{"location":"src/core/#src.core.TournamentAction","title":"TournamentAction","text":"<p>Serializable action that will be stored in tournament log and can be restored</p>"},{"location":"src/core/#src.core.TournamentAction.action","title":"action  <code>classmethod</code>","text":"<pre><code>action(func) -&gt; Callable\n</code></pre> <p>Decorator to mark a function as a tournament action.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to decorate.</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>The decorated function.</p> Source code in <code>src/core.py</code> <pre><code>@classmethod\ndef action(cls, func) -&gt; Callable:\n    \"\"\"Decorator to mark a function as a tournament action.\n\n    Args:\n        func: The function to decorate.\n\n    Returns:\n        The decorated function.\n    \"\"\"\n\n    @StandingsExport.auto_export\n    @PodsExport.auto_export\n    @functools.wraps(func)\n    def wrapper(self: Tournament, *original_args, **original_kwargs):\n        # before = self.serialize()\n        ret = func(self, *original_args, **original_kwargs)\n        cls.store(self)\n        return ret\n\n    return wrapper\n</code></pre>"},{"location":"src/core/#src.core.TournamentAction.load","title":"load  <code>classmethod</code>","text":"<pre><code>load(logdir='logs/default.json') -&gt; Tournament | None\n</code></pre> <p>Loads the tournament state from a log file.</p> <p>Parameters:</p> Name Type Description Default <code>logdir</code> <p>The path to the log file (default: 'logs/default.json').</p> <code>'logs/default.json'</code> <p>Returns:</p> Type Description <code>Tournament | None</code> <p>The loaded tournament instance, or None if the file does not exist.</p> Source code in <code>src/core.py</code> <pre><code>@classmethod\ndef load(cls, logdir=\"logs/default.json\") -&gt; Tournament | None:\n    \"\"\"Loads the tournament state from a log file.\n\n    Args:\n        logdir: The path to the log file (default: 'logs/default.json').\n\n    Returns:\n        The loaded tournament instance, or None if the file does not exist.\n    \"\"\"\n    if os.path.exists(logdir):\n        cls.LOGF = logdir\n        # try:\n        with open(cls.LOGF, \"r\") as f:\n            tour_json = json.load(f)\n            tour = Tournament.inflate(tour_json)\n        return tour\n        # except Exception as e:\n        #    Log.log(str(e), level=Log.Level.ERROR)\n        #    return None\n    return None\n</code></pre>"},{"location":"src/core/#src.core.TournamentAction.store","title":"store  <code>classmethod</code>","text":"<pre><code>store(tournament: Tournament)\n</code></pre> <p>Stores the tournament state to a log file.</p> <p>Parameters:</p> Name Type Description Default <code>tournament</code> <code>Tournament</code> <p>The tournament instance to store.</p> required Source code in <code>src/core.py</code> <pre><code>@classmethod\ndef store(cls, tournament: Tournament):\n    \"\"\"Stores the tournament state to a log file.\n\n    Args:\n        tournament: The tournament instance to store.\n    \"\"\"\n    if cls.LOGF is None:\n        cls.LOGF = cls.DEFAULT_LOGF\n    if cls.LOGF:\n        assert isinstance(cls.LOGF, str)\n        if not os.path.exists(os.path.dirname(cls.LOGF)):\n            os.makedirs(os.path.dirname(cls.LOGF))\n        with open(cls.LOGF, \"w\") as f:\n            json.dump(tournament.serialize(), f, indent=4)\n</code></pre>"},{"location":"src/core/#src.core.TournamentConfiguration","title":"TournamentConfiguration","text":"<pre><code>TournamentConfiguration(**kwargs)\n</code></pre> <p>               Bases: <code>ITournamentConfiguration</code></p> <p>Initializes the TournamentConfiguration.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Arbitrary keyword arguments using the configuration.</p> <code>{}</code> Source code in <code>src/core.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"Initializes the TournamentConfiguration.\n\n    Args:\n        **kwargs: Arbitrary keyword arguments using the configuration.\n    \"\"\"\n    self.pod_sizes = kwargs.get(\"pod_sizes\", [4, 3])\n    self.allow_bye = kwargs.get(\"allow_bye\", True)\n    self.win_points = kwargs.get(\"win_points\", 5)\n    self.bye_points = kwargs.get(\"bye_points\", 4)\n    self.draw_points = kwargs.get(\"draw_points\", 1)\n    self.snake_pods = kwargs.get(\"snake_pods\", True)\n    self.n_rounds = kwargs.get(\"n_rounds\", 5)\n    # Parse int or enum for TopCut\n    tc_val = kwargs.get(\"top_cut\", TournamentConfiguration.TopCut.NONE)\n    if isinstance(tc_val, TournamentConfiguration.TopCut):\n        self.top_cut = tc_val\n    else:\n        # If it's already an int, map to Enum\n        try:\n            self.top_cut = TournamentConfiguration.TopCut(tc_val)\n        except Exception:\n            self.top_cut = TournamentConfiguration.TopCut.NONE\n    self.max_byes = kwargs.get(\"max_byes\", 2)\n    self.auto_export = kwargs.get(\"auto_export\", True)\n    self.standings_export = kwargs.get(\"standings_export\", StandingsExport())\n    self.global_wr_seats = kwargs.get(\n        \"global_wr_seats\",\n        [\n            # 0.2553,\n            # 0.2232,\n            # 0.1847,\n            # 0.1428,\n            # New data: all 50+ player events since [2024-09-30;2025-05-05]\n            0.2470,\n            0.1928,\n            0.1672,\n            0.1458,\n        ],\n    )\n</code></pre>"},{"location":"src/core/#src.core.TournamentConfiguration.max_pod_size","title":"max_pod_size  <code>property</code>","text":"<pre><code>max_pod_size\n</code></pre> <p>Returns the maximum pod size.</p> <p>Returns:</p> Type Description <p>The maximum pod size.</p>"},{"location":"src/core/#src.core.TournamentConfiguration.min_pod_size","title":"min_pod_size  <code>property</code>","text":"<pre><code>min_pod_size\n</code></pre> <p>Returns the minimum pod size.</p> <p>Returns:</p> Type Description <p>The minimum pod size.</p>"},{"location":"src/core/#src.core.TournamentConfiguration.ranking","title":"ranking  <code>staticmethod</code>","text":"<pre><code>ranking(x: Player, tour_round: Round) -&gt; tuple\n</code></pre> <p>Calculates the ranking score for a player.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Player</code> <p>The player.</p> required <code>tour_round</code> <code>Round</code> <p>The current round.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of ranking criteria.</p> Source code in <code>src/core.py</code> <pre><code>@staticmethod\n@override\ndef ranking(x: Player, tour_round: Round) -&gt; tuple:\n    \"\"\"Calculates the ranking score for a player.\n\n    Args:\n        x: The player.\n        tour_round: The current round.\n\n    Returns:\n        A tuple of ranking criteria.\n    \"\"\"\n    return (\n        x.rating(tour_round),\n        len(x.games(tour_round)),\n        np.round(x.opponent_pointrate(tour_round), 10),\n        len(x.players_beaten(tour_round)),\n        -x.average_seat([r for r in x.tour.rounds if r.seq &lt;= tour_round.seq]),\n        -x.uid if isinstance(x.uid, int) else -int(x.uid.int),\n    )\n</code></pre>"},{"location":"src/core/#src.core.TournamentContext","title":"TournamentContext","text":"<pre><code>TournamentContext(tour: Tournament, tour_round: Round, standings: list[Player])\n</code></pre> <p>Context object holding tournament state for export operations.</p> <p>Initializes the TournamentContext.</p> <p>Parameters:</p> Name Type Description Default <code>tour</code> <code>Tournament</code> <p>The tournament instance.</p> required <code>tour_round</code> <code>Round</code> <p>The specific round of the tournament.</p> required <code>standings</code> <code>list[Player]</code> <p>The list of players in the current standings.</p> required Source code in <code>src/core.py</code> <pre><code>def __init__(self, tour: Tournament, tour_round: Round, standings: list[Player]):\n    \"\"\"Initializes the TournamentContext.\n\n    Args:\n        tour: The tournament instance.\n        tour_round: The specific round of the tournament.\n        standings: The list of players in the current standings.\n    \"\"\"\n    self.tour = tour\n    self.tour_round = tour_round\n    self.standings = standings\n</code></pre>"},{"location":"src/discord_engine/","title":"src.discord_engine","text":""},{"location":"src/discord_engine/#src.discord_engine.DiscordPoster","title":"DiscordPoster","text":"<pre><code>DiscordPoster()\n</code></pre> <p>Singleton class to post messages to Discord.</p> <p>Initializes the DiscordPoster.</p> Source code in <code>src/discord_engine.py</code> <pre><code>def __init__(self):\n    \"\"\"Initializes the DiscordPoster.\"\"\"\n    if self._initialized:\n        return\n\n    self.token: str = os.getenv(\"DISCORD_TOKEN\", \"\")\n    self.guild_id = int(os.getenv(\"GUILD_ID\", 0))\n    self.channel_id = int(os.getenv(\"CHANNEL_ID\", 0))\n\n    # Set up bot\n    intents = discord.Intents.default()\n    intents.guilds = True\n    intents.messages = True\n    self.bot = commands.Bot(command_prefix=\"!\", intents=intents)\n\n    # Message queue\n    self.message_queue = asyncio.Queue()\n\n    # To detect when loop is ready\n    self.loop_ready = threading.Event()\n\n    # Background task reference\n    self.queue_task = None\n\n    @self.bot.event\n    async def on_ready():\n        # Start queue processor inside bot's event loop\n        if not self.queue_task or self.queue_task.done():\n            self.queue_task = self.bot.loop.create_task(self._process_queued_messages())\n\n    # Start bot in background thread\n    self.thread = threading.Thread(target=self._run_bot_loop, daemon=True)\n    self.thread.start()\n\n    self.loop_ready.wait()  # Ensure loop is ready\n\n    self._initialized = True\n</code></pre>"},{"location":"src/discord_engine/#src.discord_engine.DiscordPoster.__new__","title":"__new__","text":"<pre><code>__new__()\n</code></pre> <p>Creates or returns the singleton instance.</p> Source code in <code>src/discord_engine.py</code> <pre><code>def __new__(cls):\n    \"\"\"Creates or returns the singleton instance.\"\"\"\n    with cls._lock:\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance._initialized = False\n    return cls._instance\n</code></pre>"},{"location":"src/discord_engine/#src.discord_engine.DiscordPoster.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Gracefully shut down bot and background task.</p> Source code in <code>src/discord_engine.py</code> <pre><code>async def close(self):\n    \"\"\"Gracefully shut down bot and background task.\"\"\"\n    if self.loop and self.loop.is_running():\n        await self.bot.close()\n        if self.queue_task:\n            self.queue_task.cancel()\n</code></pre>"},{"location":"src/discord_engine/#src.discord_engine.DiscordPoster.instance","title":"instance  <code>classmethod</code>","text":"<pre><code>instance()\n</code></pre> <p>Get the singleton instance.</p> Source code in <code>src/discord_engine.py</code> <pre><code>@classmethod\ndef instance(cls):\n    \"\"\"Get the singleton instance.\"\"\"\n    return cls()\n</code></pre>"},{"location":"src/discord_engine/#src.discord_engine.DiscordPoster.post_message","title":"post_message","text":"<pre><code>post_message(message: str)\n</code></pre> <p>Safely post a message from any thread using self.loop.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message to post.</p> required Source code in <code>src/discord_engine.py</code> <pre><code>def post_message(self, message: str):\n    \"\"\"Safely post a message from any thread using self.loop.\n\n    Args:\n        message: The message to post.\n    \"\"\"\n    if not self.loop or not self.loop.is_running():\n        return\n\n    future = asyncio.run_coroutine_threadsafe(self.message_queue.put(message), self.loop)\n    try:\n        future.result()  # Wait for completion\n    except Exception as e:\n        print(f\"[DiscordPoster] Error posting message: {e}\")\n</code></pre>"},{"location":"src/interface/","title":"src.interface","text":""},{"location":"src/interface/#src.interface.IHashable","title":"IHashable","text":"<pre><code>IHashable(uid: UUID | None = None)\n</code></pre> <p>Interface for hashable objects with UUIDs.</p> <p>Initializes the IHashable object.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>UUID | None</code> <p>The UUID of the object. If None, a new UUID is generated.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the UUID has a collision or is of invalid type.</p> Source code in <code>src/interface.py</code> <pre><code>def __init__(self, uid: UUID | None = None):\n    \"\"\"Initializes the IHashable object.\n\n    Args:\n        uid: The UUID of the object. If None, a new UUID is generated.\n\n    Raises:\n        ValueError: If the UUID has a collision or is of invalid type.\n    \"\"\"\n    if uid:\n        if uid in self.CACHE:\n            raise ValueError(\"UUID collision.\")\n        elif not isinstance(uid, UUID):\n            raise ValueError(\"UUID type error.\")\n        else:\n            self.uid = uid\n    else:\n        self.uid: UUID = uuid4()\n    self.CACHE[self.uid] = self\n</code></pre>"},{"location":"src/interface/#src.interface.IHashable.get","title":"get  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>get(ID: UUID) -&gt; IHashable\n</code></pre> <p>Retrieves an object by its UUID.</p> <p>Parameters:</p> Name Type Description Default <code>ID</code> <code>UUID</code> <p>The UUID of the object.</p> required <p>Returns:</p> Type Description <code>IHashable</code> <p>The object with the specified UUID.</p> Source code in <code>src/interface.py</code> <pre><code>@classmethod\n@abstractmethod\ndef get(cls, ID: UUID) -&gt; IHashable:\n    \"\"\"Retrieves an object by its UUID.\n\n    Args:\n        ID: The UUID of the object.\n\n    Returns:\n        The object with the specified UUID.\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"src/interface/#src.interface.IPairingLogic","title":"IPairingLogic","text":"<pre><code>IPairingLogic(name: str)\n</code></pre> <p>Interface for pairing logic.</p> <p>Initializes the IPairingLogic.</p> Source code in <code>src/interface.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the IPairingLogic.\"\"\"\n    self.name = name\n</code></pre>"},{"location":"src/interface/#src.interface.IPairingLogic.advance_topcut","title":"advance_topcut","text":"<pre><code>advance_topcut(tour_round: IRound, standings: list[IPlayer]) -&gt; None\n</code></pre> <p>Advances players to the top cut.</p> <p>Parameters:</p> Name Type Description Default <code>tour_round</code> <code>IRound</code> <p>The current round.</p> required <code>standings</code> <code>list[IPlayer]</code> <p>The list of players sorted by standing.</p> required Source code in <code>src/interface.py</code> <pre><code>def advance_topcut(self, tour_round: IRound, standings: list[IPlayer]) -&gt; None:\n    \"\"\"Advances players to the top cut.\n\n    Args:\n        tour_round: The current round.\n        standings: The list of players sorted by standing.\n    \"\"\"\n    raise NotImplementedError(\n        \"PairingLogic.advance_topcut not implemented - use subclass\"\n    )\n</code></pre>"},{"location":"src/interface/#src.interface.IPairingLogic.make_pairings","title":"make_pairings","text":"<pre><code>make_pairings(tour_round: IRound, players: set[IPlayer], pods: Sequence[IPod]) -&gt; Sequence[IPlayer]\n</code></pre> <p>Creates pairings for a round.</p> <p>Parameters:</p> Name Type Description Default <code>tour_round</code> <code>IRound</code> <p>The current round.</p> required <code>players</code> <code>set[IPlayer]</code> <p>The set of players to pair.</p> required <code>pods</code> <code>Sequence[IPod]</code> <p>The list of available pods.</p> required <p>Returns:</p> Type Description <code>Sequence[IPlayer]</code> <p>A sequence of players who could not be paired (if any).</p> Source code in <code>src/interface.py</code> <pre><code>def make_pairings(\n    self, tour_round: IRound, players: set[IPlayer], pods: Sequence[IPod]\n) -&gt; Sequence[IPlayer]:\n    \"\"\"Creates pairings for a round.\n\n    Args:\n        tour_round: The current round.\n        players: The set of players to pair.\n        pods: The list of available pods.\n\n    Returns:\n        A sequence of players who could not be paired (if any).\n    \"\"\"\n    raise NotImplementedError(\n        \"PairingLogic.make_pairings not implemented - use subclass\"\n    )\n</code></pre>"},{"location":"src/interface/#src.interface.IPlayer","title":"IPlayer","text":"<pre><code>IPlayer(uid: UUID | None = None)\n</code></pre> <p>               Bases: <code>IHashable</code></p> <p>Interface for a player.</p> <p>Initializes the IPlayer.</p> Source code in <code>src/interface.py</code> <pre><code>def __init__(self, uid: UUID | None = None):\n    \"\"\"Initializes the IPlayer.\"\"\"\n    super().__init__(uid=uid)\n    self.name: str = str()\n    # self.rounds: list[IRound] = list()\n    self.tour: ITournament\n</code></pre>"},{"location":"src/interface/#src.interface.IPlayer.ELocation","title":"ELocation","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum for player location.</p>"},{"location":"src/interface/#src.interface.IPlayer.EResult","title":"EResult","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum for match result.</p>"},{"location":"src/interface/#src.interface.IPod","title":"IPod","text":"<pre><code>IPod(uid: UUID | None = None)\n</code></pre> <p>               Bases: <code>IHashable</code></p> <p>Interface for a pod.</p> <p>Initializes the IPod.</p> Source code in <code>src/interface.py</code> <pre><code>def __init__(self, uid: UUID | None = None):\n    \"\"\"Initializes the IPod.\"\"\"\n    super().__init__(uid=uid)\n    self._tour: UUID\n    self._round: UUID\n    self._players: list[UUID] = list()\n    self.cap: int = 0\n    self._result: set[UUID] = set()\n</code></pre>"},{"location":"src/interface/#src.interface.IPod.EResult","title":"EResult","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum for pod result.</p>"},{"location":"src/interface/#src.interface.IRound","title":"IRound","text":"<pre><code>IRound(uid: UUID | None = None)\n</code></pre> <p>               Bases: <code>IHashable</code></p> <p>Interface for a round.</p> <p>Initializes the IRound.</p> Source code in <code>src/interface.py</code> <pre><code>def __init__(self, uid: UUID | None = None):\n    \"\"\"Initializes the IRound.\"\"\"\n    super().__init__(uid=uid)\n    self.seq: int = -1\n    self.logic: IPairingLogic\n    self._tour: UUID\n    self._pods: list[UUID] = list()\n    self._players: list[UUID] = list()\n</code></pre>"},{"location":"src/interface/#src.interface.SortMethod","title":"SortMethod","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum for sorting methods.</p>"},{"location":"src/interface/#src.interface.SortOrder","title":"SortOrder","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum for sorting order.</p>"},{"location":"src/misc/","title":"src.misc","text":""},{"location":"src/misc/#src.misc.Json2Obj","title":"Json2Obj","text":"<pre><code>Json2Obj(data)\n</code></pre> <p>Converts a dictionary to an object.</p> <p>Initializes the Json2Obj.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>The dictionary to convert.</p> required Source code in <code>src/misc.py</code> <pre><code>def __init__(self, data):\n    \"\"\"Initializes the Json2Obj.\n\n    Args:\n        data: The dictionary to convert.\n    \"\"\"\n    self.__dict__ = data\n    for i in self.__dict__.keys():\n        child = self.__dict__[i]\n        if isinstance(child, dict):\n            if len(child) &gt; 0:\n                self.__dict__[i] = Json2Obj(child)\n        if isinstance(child, list):\n            self.__dict__[i] = []\n            for item in child:\n                if isinstance(item, dict):\n                    self.__dict__[i].append(Json2Obj(item))\n                else:\n                    self.__dict__[i].append(item)\n</code></pre>"},{"location":"src/misc/#src.misc.generate_player_names","title":"generate_player_names","text":"<pre><code>generate_player_names(n: int) -&gt; list[str]\n</code></pre> <p>Generates a list of random player names.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of names to generate.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of random names.</p> Source code in <code>src/misc.py</code> <pre><code>def generate_player_names(n: int) -&gt; list[str]:\n    \"\"\"Generates a list of random player names.\n\n    Args:\n        n: The number of names to generate.\n\n    Returns:\n        A list of random names.\n    \"\"\"\n    fkr = Faker()\n    names: set[str] = set()\n    while len(names) &lt; n:\n        names.add(fkr.name())\n    return list(names)\n</code></pre>"},{"location":"src/misc/#src.misc.timeit","title":"timeit","text":"<pre><code>timeit(method)\n</code></pre> <p>Decorator to measure execution time of a function.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <p>The function to measure.</p> required <p>Returns:</p> Type Description <p>The decorated function.</p> Source code in <code>src/misc.py</code> <pre><code>def timeit(method):\n    \"\"\"Decorator to measure execution time of a function.\n\n    Args:\n        method: The function to measure.\n\n    Returns:\n        The decorated function.\n    \"\"\"\n\n    def timed(*args, **kw):\n        sys.stdout.write(\"\\rt({}) ...\".format(method.__name__))\n        sys.stdout.flush()\n\n        ts = time.time()\n        result = method(*args, **kw)\n        te = time.time()\n        if \"log_time\" in kw:\n            name = kw.get(\"log_name\", method.__name__.upper())\n            kw[\"log_time\"][name] = int((te - ts) * 1000)\n        else:\n            # print('%r  %2.2f ms' % (method.__name__, (te - ts) * 1000))\n            sys.stdout.write(\n                \"\\rt({}) = {:.2f} ms\\n\".format(method.__name__, (te - ts) * 1000)\n            )\n            sys.stdout.flush()\n        return result\n\n    return timed\n</code></pre>"}]}