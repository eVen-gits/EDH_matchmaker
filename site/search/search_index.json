{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"src/core/","title":"src.core","text":""},{"location":"src/core/#src.core.DataExport","title":"DataExport","text":"<p>Namespace for data export constants and enums.</p>"},{"location":"src/core/#src.core.DataExport.Format","title":"Format","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for export formats.</p>"},{"location":"src/core/#src.core.DataExport.Target","title":"Target","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for export targets.</p>"},{"location":"src/core/#src.core.Log","title":"Log","text":"<p>Handles logging messages with different severity levels.</p>"},{"location":"src/core/#src.core.Log.LogEntry","title":"LogEntry","text":"<pre><code>LogEntry(msg, level)\n</code></pre> <p>Represents a single log entry.</p> <p>Initializes a LogEntry.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <p>The log message.</p> required <code>level</code> <p>The severity level of the log.</p> required Source code in <code>src/core.py</code> <pre><code>def __init__(self, msg, level):\n    \"\"\"Initializes a LogEntry.\n\n    Args:\n        msg: The log message.\n        level: The severity level of the log.\n    \"\"\"\n    self.msg = msg\n    self.level = level\n</code></pre>"},{"location":"src/core/#src.core.Log.export","title":"export  <code>classmethod</code>","text":"<pre><code>export(fpath)\n</code></pre> <p>Exports the log to a file.</p> <p>Parameters:</p> Name Type Description Default <code>fpath</code> <p>The file path to export to.</p> required Source code in <code>src/core.py</code> <pre><code>@classmethod\ndef export(cls, fpath):\n    \"\"\"Exports the log to a file.\n\n    Args:\n        fpath: The file path to export to.\n    \"\"\"\n    try:\n        from pathlib import Path\n        Path(fpath).parent.mkdir(parents=True, exist_ok=True)\n        with open(fpath, 'w') as f:\n            f.writelines([str(s)+'\\n' for s in cls.output])\n    except Exception as e:\n        cls.log(str(e), level=cls.Level.ERROR)\n</code></pre>"},{"location":"src/core/#src.core.Log.log","title":"log  <code>classmethod</code>","text":"<pre><code>log(str_log, level=Level.NONE)\n</code></pre> <p>Logs a message with a specified level.</p> <p>Parameters:</p> Name Type Description Default <code>str_log</code> <p>The message to log.</p> required <code>level</code> <p>The severity level (default: Level.NONE).</p> <code>NONE</code> Source code in <code>src/core.py</code> <pre><code>@classmethod\ndef log(cls, str_log, level=Level.NONE):\n    \"\"\"Logs a message with a specified level.\n\n    Args:\n        str_log: The message to log.\n        level: The severity level (default: Level.NONE).\n    \"\"\"\n    if cls.DISABLE:\n        return\n    entry = Log.LogEntry(str_log, level)\n    cls.output.append(entry)\n    if cls.PRINT:\n        print(entry)\n</code></pre>"},{"location":"src/core/#src.core.Log.print","title":"print  <code>classmethod</code>","text":"<pre><code>print()\n</code></pre> <p>Prints all log entries to the console.</p> Source code in <code>src/core.py</code> <pre><code>@classmethod\ndef print(cls):\n    \"\"\"Prints all log entries to the console.\"\"\"\n    for entry in cls.output:\n        print(entry)\n</code></pre>"},{"location":"src/core/#src.core.Player","title":"Player","text":"<pre><code>Player(tour: Tournament, name: str, uid: UUID | None = None, decklist: str | None = None)\n</code></pre> <p>               Bases: <code>IPlayer</code></p> Source code in <code>src/core.py</code> <pre><code>def __init__(self, tour: Tournament, name:str, uid: UUID|None = None, decklist: str|None = None):\n    self._tour = tour.uid\n    super().__init__(uid=uid)\n    self.name = name\n    self.decklist = decklist\n    self.CACHE[self.uid] = self\n    self._pod_id: UUID|None = None  # Direct reference to current pod\n</code></pre>"},{"location":"src/core/#src.core.Player.average_seat","title":"average_seat","text":"<pre><code>average_seat(rounds: list[Round]) -&gt; np.float64\n</code></pre> <p>Expressed in percentage. In a 4 pod game:     seat 0: 100%     seat 1: 66.66%     seat 2: 33.33%     seat 3: 0% In a 3 pod game:     seat 0: 100%     seat 1: 50%     seat 2: 0%</p> <p>Higher percentage means better seats, statistically. In subsequent matching attempts, these will get lower priority on early seats.</p> <p>We are now using a weighted average of all the pods the player has been in. Weights are based on TC.global_wr_seats</p> Source code in <code>src/core.py</code> <pre><code>def average_seat(self, rounds:list[Round]) -&gt; np.float64:\n    \"\"\"\n    Expressed in percentage.\n    In a 4 pod game:\n        seat 0: 100%\n        seat 1: 66.66%\n        seat 2: 33.33%\n        seat 3: 0%\n    In a 3 pod game:\n        seat 0: 100%\n        seat 1: 50%\n        seat 2: 0%\n\n    Higher percentage means better seats, statistically.\n    In subsequent matching attempts, these will get lower priority on early seats.\n\n    We are now using a weighted average of all the pods the player has been in.\n    Weights are based on TC.global_wr_seats\n    \"\"\"\n    pods = [\n        self.pod(round)\n        for\n        round\n        in rounds\n        if self.pod(round) is not None\n    ]\n    if not pods:\n        return np.float64(0.5)\n    n_pods = len([p for p in pods if isinstance(p, Pod)])\n    if n_pods == 0:\n        return np.float64(0.5)\n    score = 0\n    for pod in pods:\n        if isinstance(pod, Pod):\n            index = ([x.uid for x in pod.players]).index(self.uid)\n            if index == 0:\n                score += 1\n            elif index == len(pod) - 1:\n                continue\n            else:\n                rates = self.tour.config.global_wr_seats[0:len(pod)]\n                norm_scale = 1-(np.cumsum(rates)-rates[0])/(np.sum(rates)-rates[0])\n                score += norm_scale[index]\n    return np.float64(score/n_pods)\n</code></pre>"},{"location":"src/core/#src.core.Pod","title":"Pod","text":"<pre><code>Pod(tour_round: Round, table: int, cap=0, uid: UUID | None = None)\n</code></pre> <p>               Bases: <code>IPod</code></p> Source code in <code>src/core.py</code> <pre><code>def __init__(self, tour_round: Round, table:int, cap=0, uid: UUID|None = None):\n    self._tour: UUID = tour_round.tour.uid\n    self._round: UUID = tour_round.uid\n    super().__init__(uid=uid)\n    self.table:int = table\n    self.cap:int = cap\n    self._players: list[UUID] = list()\n</code></pre>"},{"location":"src/core/#src.core.Pod.balance","title":"balance  <code>property</code>","text":"<pre><code>balance: ndarray\n</code></pre> <p>Returns a list of count of players above 50% average seat and below 50% average seat</p>"},{"location":"src/core/#src.core.Pod.players","title":"players  <code>property</code>","text":"<pre><code>players: list[Player]\n</code></pre> <p>Returns the list of players in the pod.</p>"},{"location":"src/core/#src.core.PodsExport","title":"PodsExport","text":"<p>               Bases: <code>DataExport</code></p> <p>Handles the export of tournament pods.</p>"},{"location":"src/core/#src.core.PodsExport.auto_export","title":"auto_export  <code>classmethod</code>","text":"<pre><code>auto_export(func)\n</code></pre> <p>Decorator to automatically export pods after a function call.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to decorate.</p> required <p>Returns:</p> Type Description <p>The decorated function.</p> Source code in <code>src/core.py</code> <pre><code>@classmethod\ndef auto_export(cls, func):\n    \"\"\"Decorator to automatically export pods after a function call.\n\n    Args:\n        func: The function to decorate.\n\n    Returns:\n        The decorated function.\n    \"\"\"\n    def auto_pods_export_wrapper(self: Tournament, *original_args, **original_kwargs):\n        tour_round = self.tour_round\n        ret = func(self, *original_args, **original_kwargs)\n        tour_round = tour_round or self.tour_round\n        if self.config.auto_export:\n            logf = TournamentAction.LOGF\n            if logf and tour_round:\n                # Export pods to a file named {tournament_name}_round_{round_number}.txt\n                # And also export it into {log_directory}/pods.txt\n                context = TournamentContext(self, tour_round, self.get_standings(tour_round))\n                export_str: str = '\\n\\n'.join([\n                    pod.__repr__(context=context)\n                    for pod in tour_round.pods\n                ])\n                game_lost: list[Player] = [x for x in tour_round.active_players if x.result == Player.EResult.LOSS]\n                byes = [x for x in tour_round.unassigned if x.location == Player.ELocation.UNASSIGNED and x.result == Player.EResult.BYE]\n                if len(game_lost) + len(byes) &gt; 0:\n                    max_len = max([len(p.name) for p in game_lost + byes])\n                    if self.config.allow_bye and byes:\n                        export_str += '\\n\\nByes:\\n' + '\\n'.join([\n                            \"\\t{} | pts: {}\".format(p.name.ljust(max_len), p.rating(tour_round) or '0')\n                            for p in tour_round.unassigned\n                            if p.result == Player.EResult.BYE\n                        ])\n                    if game_lost:\n                        export_str += '\\n\\nGame losses:\\n' + '\\n'.join([\n                            \"\\t{} | pts: {}\".format(\n                                p.name.ljust(max_len),\n                                p.rating(tour_round)\n                            )\n                            for p in game_lost\n                        ])\n\n                path = os.path.join(\n                    os.path.dirname(logf),\n                    os.path.basename(logf).replace('.json', ''),\n                    os.path.basename(logf).replace('.json', '_R{}.txt'.format(tour_round.seq)),\n                )\n                if not os.path.exists(os.path.dirname(path)):\n                    os.makedirs(os.path.dirname(path))\n\n                self.export_str(export_str, path, DataExport.Target.FILE)\n                if os.getenv(\"EXPORT_ONLINE_API_URL\") and os.getenv(\"EXPORT_ONLINE_API_KEY\"):\n                    self.export_str(export_str, None, DataExport.Target.WEB)\n\n\n                path = os.path.join(os.path.dirname(logf), 'pods.txt')\n                self.export_str(export_str, path, DataExport.Target.FILE)\n\n        return ret\n    return auto_pods_export_wrapper\n</code></pre>"},{"location":"src/core/#src.core.Round","title":"Round","text":"<pre><code>Round(tour: Tournament, seq: int, stage: Stage, pairing_logic: IPairingLogic, uid: UUID | None = None, dropped: set[UUID] | None = None, disabled: set[UUID] | None = None, byes: set[UUID] | None = None, game_loss: set[UUID] | None = None)\n</code></pre> <p>               Bases: <code>IRound</code></p> Source code in <code>src/core.py</code> <pre><code>def __init__(\n        self,\n        # Required\n        tour: Tournament,\n        seq: int,\n        stage: Stage,\n        pairing_logic:IPairingLogic,\n        # Optional\n        uid: UUID|None = None,\n        dropped: set[UUID]|None = None,\n        disabled: set[UUID]|None = None,\n        byes: set[UUID]|None = None,\n        game_loss: set[UUID]|None = None,\n    ):\n    self._tour: UUID = tour.uid\n    super().__init__(uid=uid)\n    self.tour.ROUND_CACHE[self.uid] = self\n    self.seq:int = seq\n    self.stage: Round.Stage = stage\n\n    self._logic = pairing_logic.name\n    self._byes: set[UUID] = set() if byes is None else byes\n    self._game_loss: set[UUID] = set() if game_loss is None else game_loss\n    self._dropped: set[UUID] = set() if dropped is None else dropped\n    self._disabled: set[UUID] = set() if disabled is None else disabled\n\n    self.player_locations_map: dict[UUID, Pod] = {}\n</code></pre>"},{"location":"src/core/#src.core.Round.done","title":"done  <code>property</code>","text":"<pre><code>done\n</code></pre> <p>Returns True if all pods in the round are done, False otherwise.</p>"},{"location":"src/core/#src.core.Round.advancing_players","title":"advancing_players","text":"<pre><code>advancing_players(standings) -&gt; list[Player]\n</code></pre> <p>Returns the players who advance to the next round. Sorted by standing in that round.</p> <p>Returns:</p> Type Description <code>list[Player]</code> <p>list[Player]: - If the round is a Swiss round, returns all active players. - If the round is a playoff round, returns the players who advance to the next round of playoffs.   It is by convention default_advancers (bye), winners, advancers by draw, in that order.</p> Source code in <code>src/core.py</code> <pre><code>def advancing_players(self, standings) -&gt; list[Player]:\n    \"\"\"\n    Returns the players who advance to the next round. Sorted by standing in that round.\n\n    Returns:\n        list[Player]:\n            - If the round is a Swiss round, returns all active players.\n            - If the round is a playoff round, returns the players who advance to the next round of playoffs.\n              It is by convention default_advancers (bye), winners, advancers by draw, in that order.\n    \"\"\"\n    # Create index map for O(1) standings lookup instead of O(n) index() calls\n    standings_index = {player: idx for idx, player in enumerate(standings)}\n\n    if self.stage == Round.Stage.SWISS:\n        return sorted(self.active_players, key=lambda x: standings_index.get(x, len(standings)))\n    else:\n        active_players_set = self.active_players  # Cache set lookup\n\n        # Collect players in three groups to maintain proper ordering:\n        # 1. Byes (sorted by standings)\n        # 2. Wins (sorted by standings)\n        # 3. Draws (one per draw pod, sorted by standings)\n        bye_players: list[Player] = []\n        win_players: list[Player] = []\n        draw_players: list[Player] = []\n        processed_draw_pods: set[Pod] = set()  # Track processed draw pods to avoid duplicates\n\n        for p in standings:\n            if p not in active_players_set:\n                continue\n\n            # Handle byes\n            if p in self.byes:\n                bye_players.append(p)\n                continue\n\n            # Get pod once per player\n            pod = p.pod(self)\n            if pod is None:\n                continue\n\n            # Handle WIN results\n            if pod.done and pod.result_type == Pod.EResult.WIN:\n                if p in pod.result:\n                    win_players.append(p)\n\n            # Handle DRAW results (only process once per pod)\n            elif pod.result_type == Pod.EResult.DRAW and pod not in processed_draw_pods:\n                processed_draw_pods.add(pod)\n                if pod.result:\n                    # Filter to only active players in the draw result\n                    active_in_draw = [p for p in pod.result if p in active_players_set]\n                    if active_in_draw:\n                        advancing_player = min(active_in_draw, key=lambda x: standings_index.get(x, len(standings)))\n                        draw_players.append(advancing_player)\n\n        # Sort each group by standings and concatenate in order\n        bye_players.sort(key=lambda x: standings_index.get(x, len(standings)))\n        win_players.sort(key=lambda x: standings_index.get(x, len(standings)))\n        draw_players.sort(key=lambda x: standings_index.get(x, len(standings)))\n\n        return bye_players + win_players + draw_players\n</code></pre>"},{"location":"src/core/#src.core.Round.disable_topcut","title":"disable_topcut","text":"<pre><code>disable_topcut(standings: list[Player])\n</code></pre> <p>Disable players who don't advance to top cut. They remain in the tournament but won't participate in top cut rounds.</p> Source code in <code>src/core.py</code> <pre><code>def disable_topcut(self, standings: list[Player]):\n    \"\"\"Disable players who don't advance to top cut.\n    They remain in the tournament but won't participate in top cut rounds.\"\"\"\n    standings = self.tour.get_standings(self.tour.previous_round(self))\n\n    # Disable players from bottom of standings until we reach top_cut size\n    for p in standings[self.stage.value::]:\n        self.disable_player(p, set_disabled=True)\n</code></pre>"},{"location":"src/core/#src.core.SortMethod","title":"SortMethod","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for sorting methods.</p>"},{"location":"src/core/#src.core.SortOrder","title":"SortOrder","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for sorting order.</p>"},{"location":"src/core/#src.core.StandingsExport","title":"StandingsExport","text":"<pre><code>StandingsExport(fields=None, format: Format = DataExport.Format.PLAIN, dir: Union[str, None] = None)\n</code></pre> <p>               Bases: <code>DataExport</code></p> Source code in <code>src/core.py</code> <pre><code>def __init__(self, fields=None, format: DataExport.Format = DataExport.Format.PLAIN, dir: Union[str, None] = None):\n    if fields is None:\n        self.fields = self.DEFAULT_FIELDS\n    else:\n        self.fields = fields\n    self.format = format\n    if dir is None:\n        self.dir = './logs/standings' + self.ext[self.format]\n    else:\n        self.dir = dir\n</code></pre>"},{"location":"src/core/#src.core.StandingsExport.inflate","title":"inflate  <code>classmethod</code>","text":"<pre><code>inflate(data: dict)\n</code></pre> <p>Creates a StandingsExport instance from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The dictionary containing the configuration.</p> required <p>Returns:</p> Type Description <p>A new StandingsExport instance.</p> Source code in <code>src/core.py</code> <pre><code>@classmethod\ndef inflate(cls, data:dict):\n    \"\"\"Creates a StandingsExport instance from a dictionary.\n\n    Args:\n        data: The dictionary containing the configuration.\n\n    Returns:\n        A new StandingsExport instance.\n    \"\"\"\n    return cls(\n        [StandingsExport.Field(f) for f in data['fields']],\n        StandingsExport.Format(data['format']),\n        data['dir']\n    )\n</code></pre>"},{"location":"src/core/#src.core.StandingsExport.serialize","title":"serialize","text":"<pre><code>serialize()\n</code></pre> <p>Serializes the export configuration.</p> <p>Returns:</p> Type Description <p>A dictionary containing the serialized configuration.</p> Source code in <code>src/core.py</code> <pre><code>def serialize(self):\n    \"\"\"Serializes the export configuration.\n\n    Returns:\n        A dictionary containing the serialized configuration.\n    \"\"\"\n    return {\n        'fields': [f.value for f in self.fields],\n        'format': self.format.value,\n        'dir': self.dir\n    }\n</code></pre>"},{"location":"src/core/#src.core.Tournament","title":"Tournament","text":"<pre><code>Tournament(config: Union[TournamentConfiguration, None] = None, uid: UUID | None = None)\n</code></pre> <p>               Bases: <code>ITournament</code></p> <p>Initializes the Tournament.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Union[TournamentConfiguration, None]</code> <p>The tournament configuration.</p> <code>None</code> <code>uid</code> <code>UUID | None</code> <p>The tournament UUID.</p> <code>None</code> Source code in <code>src/core.py</code> <pre><code>def __init__(self, config: Union[TournamentConfiguration, None]=None, uid: UUID|None=None) :  # type: ignore\n    \"\"\"Initializes the Tournament.\n\n    Args:\n        config: The tournament configuration.\n        uid: The tournament UUID.\n    \"\"\"\n    if config is None:\n        config = TournamentConfiguration()\n    super().__init__(config=config, uid=uid)\n    self._config = config\n    self.CACHE[self.uid] = self\n\n    self.PLAYER_CACHE: dict[UUID, Player] = {}\n    self.POD_CACHE: dict[UUID, Pod] = {}\n    self.ROUND_CACHE: dict[UUID, Round] = {}\n\n    self._rounds: list[UUID] = list()\n    self._players: set[UUID] = set()\n    #self._dropped: list[UUID] = list()\n    #self._disabled: list[UUID] = list()  # Players disabled from top cut (but still in tournament)\n    self._round: UUID|None = None\n</code></pre>"},{"location":"src/core/#src.core.Tournament.config","title":"config  <code>property</code> <code>writable</code>","text":"<pre><code>config: TournamentConfiguration\n</code></pre> <p>Returns the tournament configuration.</p>"},{"location":"src/core/#src.core.Tournament.draw_rate","title":"draw_rate  <code>property</code>","text":"<pre><code>draw_rate: float\n</code></pre> <p>Calculates the draw rate for the tournament.</p> <p>Returns:</p> Type Description <code>float</code> <p>The draw rate as a float.</p>"},{"location":"src/core/#src.core.Tournament.ended_rounds","title":"ended_rounds  <code>property</code>","text":"<pre><code>ended_rounds\n</code></pre> <p>Returns the list of completed rounds in the tournament.</p>"},{"location":"src/core/#src.core.Tournament.swiss_rounds","title":"swiss_rounds  <code>property</code>","text":"<pre><code>swiss_rounds\n</code></pre> <p>Returns the list of swiss rounds in the tournament.</p>"},{"location":"src/core/#src.core.Tournament.add_player","title":"add_player","text":"<pre><code>add_player(*specs: Any, **player_attrs) -&gt; list[Player]\n</code></pre> <p>Add players to the tournament.</p> <p>Parameters:</p> Name Type Description Default <code>*specs</code> <code>Any</code> <p>Player specifications. Can be: - Player object - (name, uid) tuple - (name, decklist) tuple - (name, uid, decklist) tuple - dict with 'name' key</p> <code>()</code> <code>**player_attrs</code> <p>Additional player attributes (decklist, uid, etc.)</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[Player]</code> <p>list[Player]: List of created Player objects</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If player data is invalid</p> Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef add_player(self, *specs: Any, **player_attrs) -&gt; list[Player]:\n    \"\"\"\n    Add players to the tournament.\n\n    Args:\n        *specs: Player specifications. Can be:\n            - Player object\n            - (name, uid) tuple\n            - (name, decklist) tuple\n            - (name, uid, decklist) tuple\n            - dict with 'name' key\n        **player_attrs: Additional player attributes (decklist, uid, etc.)\n\n    Returns:\n        list[Player]: List of created Player objects\n\n    Raises:\n        ValueError: If player data is invalid\n    \"\"\"\n\n    # Handle keyword arguments merging with a single positional spec\n    if player_attrs and len(specs) == 1 and 'name' not in player_attrs:\n        spec = specs[0]\n        if isinstance(spec, str):\n            data = [{\"name\": spec, **player_attrs}]\n        elif isinstance(spec, dict):\n            data = [{**spec, **player_attrs}]\n        else:\n            data = list(specs) + [player_attrs]\n    else:\n        data = list(specs)\n        if player_attrs:\n            data.append(player_attrs)\n\n    # Handle backward compatibility: single positional list\n    if len(data) == 1 and isinstance(data[0], list):\n        data = data[0]\n\n    new_players = []\n    existing_names = set([p.name for p in self.players])\n    existing_uids = set([p.uid for p in self.players])\n\n    for entry in data:\n        if entry is None:\n            continue\n\n        name, uid, decklist = None, None, None\n\n        if isinstance(entry, (tuple, list)):\n            # Handle 1-tuple (name), 2-tuple (smart: name, uid/decklist), or 3-tuple (name, uid, decklist)\n            if len(entry) == 1:\n                name = entry[0]\n            elif len(entry) == 2:\n                name, second = entry\n                if isinstance(second, UUID):\n                    uid = second\n                elif isinstance(second, (str, type(None))):\n                    decklist = second\n                else:\n                    raise ValueError(f\"Unknown type for second element in player tuple: {type(second)}\")\n            elif len(entry) == 3:\n                name, uid, decklist = entry\n            else:\n                raise ValueError(f\"Player tuple/list must have 1-3 elements, got {len(entry)}\")\n        elif isinstance(entry, dict):\n            # Handle dictionary specification\n            name = entry.get('name')\n            uid = entry.get('uid')\n            decklist = entry.get('decklist')\n        elif isinstance(entry, str):\n            # Handle single string as name\n            name = entry\n        else:\n            raise ValueError(f\"Invalid player specification type: {type(entry)}. Expected str, dict, tuple, or list.\")\n\n        if not name or not isinstance(name, str):\n            raise ValueError(f\"Player name must be a non-empty string, got {type(name)}: {name}\")\n\n        if name in existing_names:\n            Log.log('\\tPlayer {} already enlisted.'.format(\n                name), level=Log.Level.WARNING)\n            continue\n        if uid and uid in existing_uids:\n            Log.log('\\tPlayer with UID {} already enlisted.'.format(\n                uid), level=Log.Level.WARNING)\n            continue\n\n        # Create and register the player\n        p = Player(self, name, uid, decklist)\n        self._players.add(p.uid)\n        if p.uid not in self.tour_round._players:\n            self.tour_round._players.append(p.uid)\n        new_players.append(p)\n        existing_names.add(name)\n        existing_uids.add(p.uid)\n        Log.log('\\tAdded player {}'.format(\n            p.name), level=Log.Level.INFO)\n    return new_players\n</code></pre>"},{"location":"src/core/#src.core.Tournament.bench_players","title":"bench_players","text":"<pre><code>bench_players(players: Iterable[Player] | Player)\n</code></pre> <p>Removes player(s) from their current pod, effectively benching them.</p> <p>Parameters:</p> Name Type Description Default <code>players</code> <code>Iterable[Player] | Player</code> <p>The player or iterable of players to bench.</p> required Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef bench_players(self, players: Iterable[Player]|Player):\n    \"\"\"Removes player(s) from their current pod, effectively benching them.\n\n    Args:\n        players: The player or iterable of players to bench.\n    \"\"\"\n    assert self.tour_round is not None\n    if not isinstance(players, Iterable):\n        players = [players]\n    for player in players:\n        self.remove_player_from_pod(player)\n</code></pre>"},{"location":"src/core/#src.core.Tournament.create_pairings","title":"create_pairings","text":"<pre><code>create_pairings() -&gt; bool\n</code></pre> <p>Creates pairings for the current round.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if pairings were created, False otherwise.</p> Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef create_pairings(self) -&gt; bool:\n    \"\"\"Creates pairings for the current round.\n\n    Returns:\n        True if pairings were created, False otherwise.\n    \"\"\"\n    if self.last_round is None or self.last_round.done:\n        ok = self.initialize_round()\n        if not ok:\n            return False\n    #self.last_round._byes.clear()\n    assert self.last_round is not None\n    if not self.last_round.all_players_assigned:\n        self.last_round.create_pairings()\n        return True\n    return False\n</code></pre>"},{"location":"src/core/#src.core.Tournament.delete_pod","title":"delete_pod","text":"<pre><code>delete_pod(pod: Pod)\n</code></pre> <p>Deletes a specified pod from the current round.</p> <p>Parameters:</p> Name Type Description Default <code>pod</code> <code>Pod</code> <p>The pod to delete.</p> required Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef delete_pod(self, pod: Pod):\n    \"\"\"Deletes a specified pod from the current round.\n\n    Args:\n        pod: The pod to delete.\n    \"\"\"\n    if self.tour_round:\n        self.tour_round.remove_pod(pod)\n</code></pre>"},{"location":"src/core/#src.core.Tournament.disable_player","title":"disable_player","text":"<pre><code>disable_player(players: list[Player] | Player, set_disabled: bool = True) -&gt; bool\n</code></pre> <p>Disable players from top cut. They remain in the tournament but won't participate in top cut rounds.</p> <p>Parameters:</p> Name Type Description Default <code>players</code> <code>list[Player] | Player</code> <p>The player or list of players to disable.</p> required <code>set_disabled</code> <code>bool</code> <p>If True, disables the player; if False, re-enables them.</p> <code>True</code> Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef disable_player(self, players: list[Player]|Player, set_disabled: bool=True) -&gt; bool:\n    \"\"\"Disable players from top cut. They remain in the tournament but won't participate in top cut rounds.\n\n    Args:\n        players: The player or list of players to disable.\n        set_disabled: If True, disables the player; if False, re-enables them.\n    \"\"\"\n    if not isinstance(players, list):\n        players = [players]\n    for p in players:\n        self.tour_round.disable_player(p, set_disabled=set_disabled)\n    return True\n</code></pre>"},{"location":"src/core/#src.core.Tournament.discover_pairing_logic","title":"discover_pairing_logic  <code>classmethod</code>","text":"<pre><code>discover_pairing_logic() -&gt; None\n</code></pre> <p>Discover and cache all pairing logic implementations from src/pairing_logic.</p> Source code in <code>src/core.py</code> <pre><code>@classmethod\ndef discover_pairing_logic(cls) -&gt; None:\n    \"\"\"Discover and cache all pairing logic implementations from src/pairing_logic.\"\"\"\n    if cls._pairing_logic_cache:\n        return\n\n\n\n    # Get the base directory of the project\n    base_dir = Path(__file__).parent.parent\n    pairing_logic_dir = base_dir / 'src' / 'pairing_logic'\n\n    # Walk through all Python files in the pairing_logic directory\n    for module_info in pkgutil.iter_modules([str(pairing_logic_dir)]):\n        try:\n            # Import the module\n            module = importlib.import_module(f'src.pairing_logic.{module_info.name}')\n\n            # Find all classes that implement IPairingLogic\n            for name, obj in module.__dict__.items():\n                if (isinstance(obj, type) and\n                    issubclass(obj, IPairingLogic) and\n                    obj != IPairingLogic and\n                    obj.IS_COMPLETE\n                ):\n                    if obj.__name__ in cls._pairing_logic_cache:\n                        raise ValueError(f\"Pairing logic {obj.__name__} already exists\")\n                    cls._pairing_logic_cache[obj.__name__] = obj(name=f'{obj.__name__}')\n        except Exception as e:\n            Log.log(f\"Failed to import pairing logic module {module_info.name}: {e}\",\n                   level=Log.Level.WARNING)\n</code></pre>"},{"location":"src/core/#src.core.Tournament.drop_player","title":"drop_player","text":"<pre><code>drop_player(players: list[Player] | Player) -&gt; bool\n</code></pre> <p>Drops a player or list of players from the tournament.</p> <p>Parameters:</p> Name Type Description Default <code>players</code> <code>list[Player] | Player</code> <p>The player or list of players to drop.</p> required Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef drop_player(self, players: list[Player]|Player) -&gt; bool:\n    \"\"\"Drops a player or list of players from the tournament.\n\n    Args:\n        players: The player or list of players to drop.\n    \"\"\"\n    if not isinstance(players, list):\n        players = [players]\n    for p in players:\n        if self.tour_round and p.seated(self.tour_round):\n            if self.tour_round.done and self.tour_round != self.last_round:\n                #Log.log('Can\\'t drop {} during an active tour_round.\\nComplete the tour_round or remove player from pod first.'.format(\n                #    p.name), level=Log.Level.WARNING)\n                return False\n\n        # If player has not played yet, it can safely be deleted without being saved\n        if p.played(self.tour_round):\n            self.tour_round.drop_player(p)\n        else:\n            self._players.remove(p.uid)\n            self.tour_round._players.remove(p.uid)\n        # Remove from disabled set if they were disabled\n        self.tour_round.disable_player(p, set_disabled=False)\n    return True\n</code></pre>"},{"location":"src/core/#src.core.Tournament.export_str","title":"export_str","text":"<pre><code>export_str(data: str, var_export_param: Any, target_type: Target)\n</code></pre> <p>Exports a string of data to a specified target (file, web, discord, console).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The string data to export.</p> required <code>var_export_param</code> <code>Any</code> <p>Parameter specific to the target type (e.g., file path, log level).</p> required <code>target_type</code> <code>Target</code> <p>The target for the export (FILE, WEB, DISCORD, CONSOLE).</p> required Source code in <code>src/core.py</code> <pre><code>def export_str(\n        self,\n        data: str,\n        var_export_param: Any,\n        target_type: StandingsExport.Target,\n    ):\n    \"\"\"Exports a string of data to a specified target (file, web, discord, console).\n\n    Args:\n        data: The string data to export.\n        var_export_param: Parameter specific to the target type (e.g., file path, log level).\n        target_type: The target for the export (FILE, WEB, DISCORD, CONSOLE).\n    \"\"\"\n    if StandingsExport.Target.FILE == target_type:\n        if not os.path.exists(os.path.dirname(var_export_param)):\n            os.makedirs(os.path.dirname(var_export_param))\n        with open(var_export_param, 'w', encoding='utf-8') as f:\n            f.writelines(data)\n\n    if StandingsExport.Target.WEB == target_type:\n        api = os.getenv(\"EXPORT_ONLINE_API_URL\")\n        key = os.getenv(\"EXPORT_ONLINE_API_KEY\")\n        if not key or not api:\n            Log.log(\"Error: EXPORT_ONLINE_API_URL or EXPORT_ONLINE_API_KEY not set in the environment variables.\")\n            return\n        tournament_id = os.getenv(\"TOURNAMENT_ID\")\n        url = f\"{api}?tournamentId={tournament_id}\"\n\n        # Send as POST request to the Express app with authentication\n        headers = {\n            \"x-api-key\": key\n        }\n        request_data = {\n            \"title\": \"Tournament Update\",\n            \"timestamp\": f\"{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\",\n            \"text\": data,\n            \"tournament\": self.serialize(),\n        }\n\n        thread = threading.Thread(target=self.send_request, args=(url, request_data, headers))\n        thread.start()\n\n    if StandingsExport.Target.DISCORD == target_type:\n        instance = DiscordPoster.instance()\n        instance.post_message(data)\n\n    if StandingsExport.Target.CONSOLE == target_type:\n        if not isinstance(var_export_param, Log.Level):\n            var_export_param = Log.Level.INFO\n        Log.log(data, level=var_export_param)\n</code></pre>"},{"location":"src/core/#src.core.Tournament.get","title":"get  <code>classmethod</code>","text":"<pre><code>get(uid: UUID) -&gt; Tournament\n</code></pre> <p>Retrieves a tournament by its UUID.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>UUID</code> <p>The tournament UUID.</p> required <p>Returns:</p> Type Description <code>Tournament</code> <p>The tournament instance.</p> Source code in <code>src/core.py</code> <pre><code>@classmethod\ndef get(cls, uid: UUID) -&gt; Tournament:\n    \"\"\"Retrieves a tournament by its UUID.\n\n    Args:\n        uid: The tournament UUID.\n\n    Returns:\n        The tournament instance.\n    \"\"\"\n    return cls.CACHE[uid]\n</code></pre>"},{"location":"src/core/#src.core.Tournament.get_pairing_logic","title":"get_pairing_logic  <code>classmethod</code>","text":"<pre><code>get_pairing_logic(logic_name: str) -&gt; IPairingLogic\n</code></pre> <p>Get a pairing logic instance by name.</p> <p>Parameters:</p> Name Type Description Default <code>logic_name</code> <code>str</code> <p>The name of the pairing logic.</p> required <p>Returns:</p> Type Description <code>IPairingLogic</code> <p>The pairing logic class.</p> Source code in <code>src/core.py</code> <pre><code>@classmethod\ndef get_pairing_logic(cls, logic_name: str) -&gt; IPairingLogic:\n    \"\"\"Get a pairing logic instance by name.\n\n    Args:\n        logic_name: The name of the pairing logic.\n\n    Returns:\n        The pairing logic class.\n    \"\"\"\n    cls.discover_pairing_logic()\n\n    if logic_name not in cls._pairing_logic_cache:\n        raise ValueError(f\"Unknown pairing logic: {logic_name}\")\n\n    return cls._pairing_logic_cache[logic_name]\n</code></pre>"},{"location":"src/core/#src.core.Tournament.get_pod_sizes","title":"get_pod_sizes","text":"<pre><code>get_pod_sizes(n) -&gt; list[int] | None\n</code></pre> <p>Determines possible pod sizes for a given number of players based on configuration.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <p>The number of players.</p> required <p>Returns:</p> Type Description <code>list[int] | None</code> <p>A list of integers representing the sizes of the pods, or None if no valid combination is found.</p> Source code in <code>src/core.py</code> <pre><code>def get_pod_sizes(self, n) -&gt; list[int]|None:\n    \"\"\"Determines possible pod sizes for a given number of players based on configuration.\n\n    Args:\n        n: The number of players.\n\n    Returns:\n        A list of integers representing the sizes of the pods, or None if no valid combination is found.\n    \"\"\"\n    # Stack to store (remaining_players, current_pod_size_index, current_solution)\n    stack = [(n, 0, [])]\n\n    while stack:\n        remaining, pod_size_idx, current_solution = stack.pop()\n\n        # If we've processed all pod sizes, continue to next iteration\n        if pod_size_idx &gt;= len(self.config.pod_sizes):\n            continue\n\n        pod_size = self.config.pod_sizes[pod_size_idx]\n        rem = remaining - pod_size\n\n        # Skip if this pod size would exceed remaining players\n        if rem &lt; 0:\n            stack.append((remaining, pod_size_idx + 1, current_solution))\n            continue\n\n        # If this pod size exactly matches remaining players, we found a solution\n        if rem == 0:\n            return current_solution + [pod_size]\n\n        # Handle case where remaining players is less than minimum pod size\n        if rem &lt; self.config.min_pod_size:\n            if self.config.allow_bye and rem &lt;= self.config.max_byes:\n                return current_solution + [pod_size]\n            elif pod_size == self.config.pod_sizes[-1]:\n                continue\n            else:\n                stack.append((remaining, pod_size_idx + 1, current_solution))\n                continue\n\n        # If remaining players is valid, try this pod size and continue with remaining players\n        if rem &gt;= self.config.min_pod_size:\n            stack.append((remaining, pod_size_idx + 1, current_solution))\n            stack.append((rem, 0, current_solution + [pod_size]))\n\n    return None\n</code></pre>"},{"location":"src/core/#src.core.Tournament.get_pods_str","title":"get_pods_str","text":"<pre><code>get_pods_str() -&gt; str\n</code></pre> <p>Generates a string representation of the current round's pods.</p> <p>Returns:</p> Type Description <code>str</code> <p>A formatted string showing the pods and players, including byes if applicable.</p> Source code in <code>src/core.py</code> <pre><code>def get_pods_str(self) -&gt; str:\n    \"\"\"Generates a string representation of the current round's pods.\n\n    Returns:\n        A formatted string showing the pods and players, including byes if applicable.\n    \"\"\"\n    if not self.tour_round:\n        return ''\n    standings = self.get_standings(self.tour_round)\n    export_str = '\\n\\n'.join([\n        pod.__repr__(TournamentContext(self, self.tour_round, standings))\n        for pod in self.tour_round.pods\n    ])\n\n    if self.config.allow_bye and self.tour_round.unassigned:\n        export_str += '\\n\\nByes:\\n' + '\\n:'.join([\n            \"\\t{}\\t| pts: {}\".format(p.name, p.rating(self.tour_round) or '0')\n            for p in self.tour_round.unassigned\n        ])\n    return export_str\n</code></pre>"},{"location":"src/core/#src.core.Tournament.get_standings","title":"get_standings","text":"<pre><code>get_standings(tour_round: Round | None = None) -&gt; list[Player]\n</code></pre> <p>Calculates and returns the current standings of players.</p> <p>Parameters:</p> Name Type Description Default <code>tour_round</code> <code>Round | None</code> <p>The round for which to calculate standings. Defaults to the current round.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Player]</code> <p>A list of Player objects, sorted by their standing.</p> Source code in <code>src/core.py</code> <pre><code>def get_standings(self, tour_round:Round|None=None) -&gt; list[Player]:\n    \"\"\"Calculates and returns the current standings of players.\n\n    Args:\n        tour_round: The round for which to calculate standings. Defaults to the current round.\n\n    Returns:\n        A list of Player objects, sorted by their standing.\n    \"\"\"\n    method = Player.SORT_METHOD\n    order = Player.SORT_ORDER\n    Player.SORT_METHOD = SortMethod.RANK\n    Player.SORT_ORDER = SortOrder.ASCENDING\n    playoffs = False\n    if tour_round is None:\n        tour_round = self.tour_round\n    if tour_round.stage == Round.Stage.SWISS:\n        standings = sorted(self.players, key=lambda x: self.config.ranking(x, tour_round), reverse=True)\n    else:\n        final_swiss = self.final_swiss_round\n        assert final_swiss is not None\n        playoff_stage = tour_round.seq - final_swiss.seq - 1\n\n        if playoff_stage &gt; 0:\n            #TODO: take the standings of previous playoff round and modify them to current results\n            previous_round = self.previous_round(tour_round)\n            assert previous_round is not None\n            standings = self.get_standings(previous_round)\n            advancing_players = tour_round.advancing_players(standings)\n            non_advancing = [p for p in standings if p not in advancing_players]\n            standings = advancing_players + non_advancing\n            pass\n        else:\n            swiss_standings = self.get_standings(final_swiss)\n            advancing_players = tour_round.advancing_players(swiss_standings)\n            non_advancing = [p for p in swiss_standings if p not in advancing_players]\n\n            # Sort non-advancing players: draws rank above losses, then by original standings\n            standings_index = {player: idx for idx, player in enumerate(swiss_standings)}\n            non_advancing.sort(key=lambda x: (\n                0 if tour_round and x.result(tour_round) == Player.EResult.DRAW else 1,  # Draws first (0), losses second (1)\n                standings_index.get(x, len(swiss_standings))  # Then by original standings position\n            ))\n\n            standings = advancing_players + non_advancing\n            pass\n\n        #TODO: Implement playoff standings\n        pass\n\n    Player.SORT_METHOD = method\n    Player.SORT_ORDER = order\n    return standings\n</code></pre>"},{"location":"src/core/#src.core.Tournament.get_standings_str","title":"get_standings_str","text":"<pre><code>get_standings_str(fields: list[Field] = StandingsExport.DEFAULT_FIELDS, style: Format = StandingsExport.Format.PLAIN, tour_round: Round | None = None, standings: list[Player] | None = None) -&gt; str\n</code></pre> <p>Generates a formatted string of the tournament standings.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>list[Field]</code> <p>A list of StandingsExport.Field to include in the standings.</p> <code>DEFAULT_FIELDS</code> <code>style</code> <code>Format</code> <p>The desired output format (e.g., PLAIN, CSV, DISCORD, JSON).</p> <code>PLAIN</code> <code>tour_round</code> <code>Round | None</code> <p>The round for which to generate standings. Defaults to the current round.</p> <code>None</code> <code>standings</code> <code>list[Player] | None</code> <p>Pre-calculated standings. If None, standings will be calculated.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A string containing the formatted standings.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid style is provided.</p> Source code in <code>src/core.py</code> <pre><code>def get_standings_str(\n        self,\n        fields: list[StandingsExport.Field] = StandingsExport.DEFAULT_FIELDS,\n        style: StandingsExport.Format = StandingsExport.Format.PLAIN,\n        tour_round: Round|None = None,\n        standings: list[Player]|None = None\n    ) -&gt; str:\n    \"\"\"Generates a formatted string of the tournament standings.\n\n    Args:\n        fields: A list of StandingsExport.Field to include in the standings.\n        style: The desired output format (e.g., PLAIN, CSV, DISCORD, JSON).\n        tour_round: The round for which to generate standings. Defaults to the current round.\n        standings: Pre-calculated standings. If None, standings will be calculated.\n\n    Returns:\n        A string containing the formatted standings.\n\n    Raises:\n        ValueError: If an invalid style is provided.\n    \"\"\"\n    #raise DeprecationWarning(\"get_standings_str is deprecated. Use get_standings instead.\")\n    if tour_round is None:\n        tour_round = self.tour_round\n    if standings is None:\n        standings = self.get_standings(tour_round)\n\n    # Create context with all available data\n    context = TournamentContext(\n        tour=self,\n        tour_round=tour_round,\n        standings=standings,\n    )\n\n    lines = [[StandingsExport.info[f].name for f in fields]]\n    lines += [\n        [\n            (StandingsExport.info[f].format).format(\n                StandingsExport.info[f].get(p, context)\n                if StandingsExport.info[f].denom is None\n                else StandingsExport.info[f].get(p, context) * StandingsExport.info[f].denom\n            )\n            for f in fields\n        ]\n        for p in standings\n    ]\n    if style == StandingsExport.Format.PLAIN:\n        col_len = [0] * len(fields)\n        for col in range(len(fields)):\n            for line in lines:\n                if len(line[col]) &gt; col_len[col]:\n                    col_len[col] = len(line[col])\n        for line in lines:\n            for col in range(len(fields)):\n                line[col] = line[col].ljust(col_len[col])\n        # add new line at index 1\n        lines.insert(1, ['-' * width for width in col_len])\n        lines = '\\n'.join([' | '.join(line) for line in lines])\n        return lines\n\n\n        # Log.log('Log saved: {}.'.format(\n        #    fdir), level=Log.Level.INFO)\n    elif style == StandingsExport.Format.CSV:\n        Log.log('Log not saved - CSV not implemented.'.format(\n            fdir), level=Log.Level.WARNING)\n    elif style == StandingsExport.Format.DISCORD:\n        Log.log('Log not saved - DISCORD not implemented.'.format(\n            fdir), level=Log.Level.WARNING)\n    elif style == StandingsExport.Format.JSON:\n        Log.log('Log not saved - JSON not implemented.'.format(\n            fdir), level=Log.Level.WARNING)\n\n    raise ValueError('Invalid style: {}'.format(style))\n</code></pre>"},{"location":"src/core/#src.core.Tournament.inflate","title":"inflate  <code>classmethod</code>","text":"<pre><code>inflate(data: dict[str, Any]) -&gt; Tournament\n</code></pre> <p>Inflates a Tournament object from serialized data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>A dictionary containing the serialized tournament data.</p> required <p>Returns:</p> Type Description <code>Tournament</code> <p>A Tournament instance.</p> Source code in <code>src/core.py</code> <pre><code>@classmethod\ndef inflate(cls, data: dict[str, Any]) -&gt; Tournament:\n    \"\"\"Inflates a Tournament object from serialized data.\n\n    Args:\n        data: A dictionary containing the serialized tournament data.\n\n    Returns:\n        A Tournament instance.\n    \"\"\"\n    config = TournamentConfiguration.inflate(data['config'])\n    tour_uid = UUID(data['uid'])\n    if tour_uid in Tournament.CACHE:\n        tour = Tournament.CACHE[tour_uid]\n    else:\n        tour = cls(config, tour_uid)\n    tour._players = {UUID(d_player['uid']) for d_player in data['players']}\n    #tour._dropped = [UUID(d_player['uid']) for d_player in data['dropped']]\n    #tour._disabled = [UUID(d_player['uid']) for d_player in data['disabled']]\n    #tour._players.extend(tour._dropped)\n    #tour._players.extend(tour._disabled)\n    # Load disabled players (backward compatible: may not exist in old saves)\n    #if 'disabled' in data:\n    #    tour._disabled = {UUID(uid) for uid in data['disabled']}\n    for d_player in data['players']:\n        Player.inflate(tour, d_player)\n    #for d_player in data['dropped']:\n    #    Player.inflate(tour, d_player)\n    tour._rounds = [UUID(d_round['uid']) for d_round in data['rounds']]\n    for _, d_round in tqdm(enumerate(data['rounds']), desc=\"Inflating rounds\"):\n        r = Round.inflate(tour, d_round)\n        tour._round = r.uid\n    return tour\n</code></pre>"},{"location":"src/core/#src.core.Tournament.initialize_round","title":"initialize_round","text":"<pre><code>initialize_round() -&gt; bool\n</code></pre> <p>Initializes a new round in the tournament, determining its stage and pairing logic.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if a new round was successfully initialized, False otherwise.</p> Source code in <code>src/core.py</code> <pre><code>def initialize_round(self) -&gt; bool:\n    \"\"\"Initializes a new round in the tournament, determining its stage and pairing logic.\n\n    Returns:\n        True if a new round was successfully initialized, False otherwise.\n    \"\"\"\n    if self._round is not None and not self.tour_round.done:\n        return False\n    seq = len(self.rounds)\n    stage = Round.Stage.SWISS\n    logic = None\n    if seq &gt;= self.config.n_rounds and self.last_round:\n        if self.config.top_cut == TournamentConfiguration.TopCut.NONE:\n            Log.log('Maximum number of rounds reached.', level=Log.Level.WARNING)\n            return False\n        if self.config.top_cut == TournamentConfiguration.TopCut.TOP_4:\n            if self.last_round.stage == Round.Stage.SWISS:\n                logic = self.get_pairing_logic(\"PairingTop4\")\n                stage = Round.Stage.TOP_4\n            else:\n                Log.log('Tournament completed.')\n                return False\n        elif self.config.top_cut == TournamentConfiguration.TopCut.TOP_7:\n            if self.last_round.stage == Round.Stage.SWISS:\n                stage = Round.Stage.TOP_7\n                logic = self.get_pairing_logic(\"PairingTop7\")\n            elif self.last_round.stage == Round.Stage.TOP_7:\n                stage = Round.Stage.TOP_4\n                logic = self.get_pairing_logic(\"PairingTop4\")\n            else:\n                Log.log('Tournament completed.')\n                return False\n        elif self.config.top_cut == TournamentConfiguration.TopCut.TOP_10:\n            if self.last_round.stage == Round.Stage.SWISS:\n                stage = Round.Stage.TOP_10\n                logic = self.get_pairing_logic(\"PairingTop10\")\n            elif self.last_round.stage == Round.Stage.TOP_10:\n                stage = Round.Stage.TOP_4\n                logic = self.get_pairing_logic(\"PairingTop4\")\n            else:\n                Log.log('Tournament completed.')\n                return False\n        elif self.config.top_cut == TournamentConfiguration.TopCut.TOP_13:\n            if self.last_round.stage == Round.Stage.SWISS:\n                stage = Round.Stage.TOP_13\n                logic = self.get_pairing_logic(\"PairingTop13\")\n            elif self.last_round.stage == Round.Stage.TOP_13:\n                stage = Round.Stage.TOP_4\n                logic = self.get_pairing_logic(\"PairingTop4\")\n            else:\n                Log.log('Tournament completed.')\n                return False\n        elif self.config.top_cut == TournamentConfiguration.TopCut.TOP_16:\n            if self.last_round.stage == Round.Stage.SWISS:\n                stage = Round.Stage.TOP_16\n                logic = self.get_pairing_logic(\"PairingTop16\")\n            elif self.last_round.stage == Round.Stage.TOP_16:\n                stage = Round.Stage.TOP_4\n                logic = self.get_pairing_logic(\"PairingTop4\")\n            else:\n                Log.log('Tournament completed.')\n                return False\n        elif self.config.top_cut == TournamentConfiguration.TopCut.TOP_40:\n            if self.last_round.stage == Round.Stage.SWISS:\n                stage = Round.Stage.TOP_40\n                logic = self.get_pairing_logic(\"PairingTop40\")\n            elif self.last_round.stage == Round.Stage.TOP_40:\n                stage = Round.Stage.TOP_16\n                logic = self.get_pairing_logic(\"PairingTop16\")\n            elif self.last_round.stage == Round.Stage.TOP_16:\n                stage = Round.Stage.TOP_4\n                logic = self.get_pairing_logic(\"PairingTop4\")\n            else:\n                Log.log('Tournament completed.')\n                return False\n        else:\n            raise ValueError(f\"Unknown top cut: {self.config.top_cut}\")\n    else:\n        if seq == 0:\n            logic = self.get_pairing_logic(\"PairingRandom\")\n        elif seq == 1 and self.config.snake_pods:\n            logic = self.get_pairing_logic(\"PairingSnake\")\n        else:\n            logic = self.get_pairing_logic(\"PairingDefault\")\n\n    if not logic:\n        Log.log('No pairing logic found.', level=Log.Level.ERROR)\n        return False\n    elif not stage:\n        Log.log('No stage found.', level=Log.Level.ERROR)\n        return False\n    new_round = Round(\n        self,\n        len(self.rounds),\n        stage,\n        logic,\n        dropped=self.tour_round._dropped if self._round else set(),\n        disabled=self.tour_round._disabled if self._round else set(),\n    )\n    self._rounds.append(new_round.uid)\n    self.tour_round = new_round\n    return True\n</code></pre>"},{"location":"src/core/#src.core.Tournament.manual_pod","title":"manual_pod","text":"<pre><code>manual_pod(players: list[Player])\n</code></pre> <p>Creates a manual pod with the specified players.</p> <p>Parameters:</p> Name Type Description Default <code>players</code> <code>list[Player]</code> <p>A list of players to include in the manual pod.</p> required Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef manual_pod(self, players: list[Player]):\n    \"\"\"Creates a manual pod with the specified players.\n\n    Args:\n        players: A list of players to include in the manual pod.\n    \"\"\"\n    if self.tour_round is None or self.tour_round.done:\n       if not self.new_round():\n            return\n    assert isinstance(self.tour_round, Round)\n    cap = min(self.config.max_pod_size, len(self.tour_round.unassigned))\n    pod = Pod(self.tour_round, len(self.tour_round.pods), cap=cap)\n    self.tour_round._pods.append(pod.uid)\n\n    for player in players:\n        pod.add_player(player)\n    self.tour_round.pods.append(pod)\n</code></pre>"},{"location":"src/core/#src.core.Tournament.move_player_to_pod","title":"move_player_to_pod","text":"<pre><code>move_player_to_pod(pod: Pod, players: list[Player] | Player, manual=False)\n</code></pre> <p>Moves a player or list of players to a specified pod.</p> <p>Parameters:</p> Name Type Description Default <code>pod</code> <code>Pod</code> <p>The target pod.</p> required <code>players</code> <code>list[Player] | Player</code> <p>The player or list of players to move.</p> required <code>manual</code> <p>If True, allows adding players even if the pod is full.</p> <code>False</code> Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef move_player_to_pod(self, pod: Pod, players: list[Player]|Player, manual=False):\n    \"\"\"Moves a player or list of players to a specified pod.\n\n    Args:\n        pod: The target pod.\n        players: The player or list of players to move.\n        manual: If True, allows adding players even if the pod is full.\n    \"\"\"\n    if not isinstance(players, list):\n        players = [players]\n    for player in players:\n        if player.pod(self.tour_round) == pod:\n            continue\n            #player.pod(self.tour_round).remove_player(player)\n            #Log.log('Removed player {} from {}.'.format(\n            #    player.name, old_pod), level=Log.Level.INFO)\n        if ok:=pod.add_player(player, manual=manual):\n            pass\n</code></pre>"},{"location":"src/core/#src.core.Tournament.new_round","title":"new_round","text":"<pre><code>new_round() -&gt; bool\n</code></pre> <p>Starts a new round.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if a new round was successfully started, False otherwise.</p> Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef new_round(self) -&gt; bool:\n    \"\"\"Starts a new round.\n\n    Returns:\n        True if a new round was successfully started, False otherwise.\n    \"\"\"\n    if not self.last_round or self.last_round.done:\n        return self.initialize_round()\n    return False\n</code></pre>"},{"location":"src/core/#src.core.Tournament.random_results","title":"random_results","text":"<pre><code>random_results()\n</code></pre> <p>Generates random results for all incomplete pods in the current round.</p> Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef random_results(self):\n    \"\"\"Generates random results for all incomplete pods in the current round.\"\"\"\n    if not self.tour_round:\n        #Log.log(\n        #    'A tour_round is not in progress.\\nCreate pods first!',\n        #    level=Log.Level.ERROR\n        #)\n        return\n    if self.tour_round.pods:\n        draw_rate = 1-sum(self.config.global_wr_seats)\n        #for each pod\n        #generate a random result based on global_winrates_by_seat\n        #each value corresponds to the pointrate of the player in that seat\n        #the sum of percentages is less than 1, so there is a chance of a draw (1-sum(winrates))\n\n        for pod in [x for x in self.tour_round.pods if not x.done]:\n            #generate a random result\n            result = random.random()\n            rates = np.array(self.config.global_wr_seats[0:len(pod.players)] + [draw_rate])\n            rates = np.cumsum(rates/sum(rates))\n            draw = result &gt; rates[-2]\n            if not draw:\n                win = np.argmax([result &lt; x for x in rates])\n                #Log.log('won \"{}\"'.format(pod.players[win].name))\n                self.tour_round.set_result(pod.players[win], Player.EResult.WIN)\n                #player = random.sample(pod.players, 1)[0]\n                #Log.log('won \"{}\"'.format(player.name))\n                #self.tour_round.won([player])\n            else:\n                players = pod.players\n                #Log.log('draw {}'.format(\n                #    ' '.join(['\"{}\"'.format(p.name) for p in players])))\n                for p in players:\n                    self.tour_round.set_result(p, Player.EResult.DRAW)\n            pass\n    pass\n</code></pre>"},{"location":"src/core/#src.core.Tournament.rating","title":"rating","text":"<pre><code>rating(player: Player, tour_round: Round) -&gt; float\n</code></pre> <p>Calculate the rating of a player for a given round. The rating is the sum of the points for the player in the Swiss rounds up to and including the given round. If the round is not a Swiss round, the rating is the sum of the points for the player in the last Swiss round.</p> <p>Parameters:</p> Name Type Description Default <code>player</code> <code>Player</code> <p>The player for whom to calculate the rating.</p> required <code>tour_round</code> <code>Round</code> <p>The round up to which to calculate the rating.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The player's rating as a float.</p> Source code in <code>src/core.py</code> <pre><code>def rating(self, player: Player, tour_round: Round) -&gt; float:\n    \"\"\"\n    Calculate the rating of a player for a given round.\n    The rating is the sum of the points for the player in the Swiss rounds up to and including the given round.\n    If the round is not a Swiss round, the rating is the sum of the points for the player in the last Swiss round.\n\n    Args:\n        player: The player for whom to calculate the rating.\n        tour_round: The round up to which to calculate the rating.\n\n    Returns:\n        The player's rating as a float.\n    \"\"\"\n    points = 0\n    for i, i_tour_round in enumerate(self.rounds):\n        if i_tour_round.stage != Round.Stage.SWISS:\n            break\n        round_result = player.result(i_tour_round)\n        if round_result == Player.EResult.WIN:\n            points += self.config.win_points\n        elif round_result == Player.EResult.DRAW:\n            points += self.config.draw_points\n        elif round_result == Player.EResult.BYE:\n            points += self.config.bye_points\n        if i_tour_round == tour_round:\n            break\n    return points\n</code></pre>"},{"location":"src/core/#src.core.Tournament.remove_player_from_pod","title":"remove_player_from_pod","text":"<pre><code>remove_player_from_pod(player: Player)\n</code></pre> <p>Removes a player from their current pod.</p> <p>Parameters:</p> Name Type Description Default <code>player</code> <code>Player</code> <p>The player to remove.</p> required Source code in <code>src/core.py</code> <pre><code>def remove_player_from_pod(self, player: Player):\n    \"\"\"Removes a player from their current pod.\n\n    Args:\n        player: The player to remove.\n    \"\"\"\n    assert self.tour_round is not None\n    pod = player.pod(self.tour_round)\n    if pod:\n        pod.remove_player(player)\n</code></pre>"},{"location":"src/core/#src.core.Tournament.rename_player","title":"rename_player","text":"<pre><code>rename_player(player, new_name)\n</code></pre> <p>Renames a player in the tournament.</p> <p>Parameters:</p> Name Type Description Default <code>player</code> <p>The player to rename.</p> required <code>new_name</code> <p>The new name for the player.</p> required Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef rename_player(self, player, new_name):\n    \"\"\"Renames a player in the tournament.\n\n    Args:\n        player: The player to rename.\n        new_name: The new name for the player.\n    \"\"\"\n    if player.name == new_name:\n        return\n    if new_name in [p.name for p in self.active_players]:\n        Log.log('\\tPlayer {} already enlisted.'.format(\n            new_name), level=Log.Level.WARNING)\n        return\n    if new_name:\n        player.name = new_name\n        for tour_round in self.rounds:\n            for pod in tour_round.pods:\n                for p in pod.players:\n                    if p.name == player.name:\n                        p.name = new_name\n        Log.log('\\tRenamed player {} to {}'.format(\n            player.name, new_name), level=Log.Level.INFO)\n</code></pre>"},{"location":"src/core/#src.core.Tournament.report_draw","title":"report_draw","text":"<pre><code>report_draw(players: list[Player] | Player)\n</code></pre> <p>Reports a draw for the specified player(s) in the current round.</p> <p>Parameters:</p> Name Type Description Default <code>players</code> <code>list[Player] | Player</code> <p>The player or list of players who drew.</p> required Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef report_draw(self, players: list[Player]|Player):\n    \"\"\"Reports a draw for the specified player(s) in the current round.\n\n    Args:\n        players: The player or list of players who drew.\n    \"\"\"\n    if self.tour_round:\n        if not isinstance(players, list):\n            players = [players]\n        for p in players:\n            self.tour_round.set_result(p, Player.EResult.DRAW)\n</code></pre>"},{"location":"src/core/#src.core.Tournament.report_win","title":"report_win","text":"<pre><code>report_win(players: list[Player] | Player)\n</code></pre> <p>Reports a win for the specified player(s) in the current round.</p> <p>Parameters:</p> Name Type Description Default <code>players</code> <code>list[Player] | Player</code> <p>The player or list of players who won.</p> required Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef report_win(self, players: list[Player]|Player):\n    \"\"\"Reports a win for the specified player(s) in the current round.\n\n    Args:\n        players: The player or list of players who won.\n    \"\"\"\n    if self.tour_round:\n        if not isinstance(players, list):\n            players = [players]\n        for p in players:\n            self.tour_round.set_result(p, Player.EResult.WIN)\n</code></pre>"},{"location":"src/core/#src.core.Tournament.reset_pods","title":"reset_pods","text":"<pre><code>reset_pods() -&gt; bool\n</code></pre> <p>Resets the pods for the current round.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if pods were reset, False otherwise.</p> Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef reset_pods(self) -&gt; bool:\n    \"\"\"Resets the pods for the current round.\n\n    Returns:\n        True if pods were reset, False otherwise.\n    \"\"\"\n    if not self.tour_round:\n        return False\n    if not self.tour_round.done:\n        if not self.tour_round.reset_pods():\n            return False\n        return True\n    return False\n</code></pre>"},{"location":"src/core/#src.core.Tournament.send_request","title":"send_request  <code>staticmethod</code>","text":"<pre><code>send_request(api, data, headers)\n</code></pre> <p>Sends a POST request to a specified API endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>api</code> <p>The API endpoint URL.</p> required <code>data</code> <p>The JSON data to send.</p> required <code>headers</code> <p>A dictionary of HTTP headers.</p> required Source code in <code>src/core.py</code> <pre><code>@staticmethod\ndef send_request(api, data, headers):\n    \"\"\"Sends a POST request to a specified API endpoint.\n\n    Args:\n        api: The API endpoint URL.\n        data: The JSON data to send.\n        headers: A dictionary of HTTP headers.\n    \"\"\"\n    try:\n        response = requests.post(\n            api,\n            json=data,\n            headers=headers,\n            timeout=10\n        )\n        if response.status_code == 200:\n            Log.log(\"Data successfully sent to the server!\")\n        else:\n            Log.log(f\"Failed to send data. Status code: {response.status_code}\")\n    except Exception as e:\n        Log.log(f\"Error sending data: {e}\", level=Log.Level.ERROR)\n</code></pre>"},{"location":"src/core/#src.core.Tournament.serialize","title":"serialize","text":"<pre><code>serialize() -&gt; dict[str, Any]\n</code></pre> <p>Returns a JSON string of the tournament, that can be serialized. It contains:     - tournament configuration json (serialized from class)     - a list of player jsons (serialized from class)     - a list of pod jsons (serialized from class)     - a list of tour_round jsons (serialized from class)</p> <p>Objects are referenced to each other by ids.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary representing the serialized tournament data.</p> Source code in <code>src/core.py</code> <pre><code>def serialize(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Returns a JSON string of the tournament, that can be serialized.\n    It contains:\n        - tournament configuration json (serialized from class)\n        - a list of player jsons (serialized from class)\n        - a list of pod jsons (serialized from class)\n        - a list of tour_round jsons (serialized from class)\n\n    Objects are referenced to each other by ids.\n\n    Returns:\n        A dictionary representing the serialized tournament data.\n    \"\"\"\n\n    data: dict[str, Any] = {}\n    data['uid'] = str(self.uid)\n    data['config'] = self.config.serialize()\n    data['players'] = list(p.serialize() for p in self.players)\n    #data['dropped'] = [p.serialize() for p in self.dropped_players]\n    #data['disabled'] = [str(p.uid) for p in self.disabled_players]\n    data['rounds'] = [r.serialize() for r in self.rounds]\n    return data\n</code></pre>"},{"location":"src/core/#src.core.Tournament.toggle_bye","title":"toggle_bye","text":"<pre><code>toggle_bye(players: Iterable[Player] | Player)\n</code></pre> <p>Toggles the bye status for player(s).</p> <p>If a player is assigned a bye, they are removed from their pod and marked as having a bye. If they already have a bye, it is removed.</p> <p>Parameters:</p> Name Type Description Default <code>players</code> <code>Iterable[Player] | Player</code> <p>The player or iterable of players to toggle bye for.</p> required Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef toggle_bye(self, players: Iterable[Player]|Player):\n    \"\"\"Toggles the bye status for player(s).\n\n    If a player is assigned a bye, they are removed from their pod and marked as having a bye.\n    If they already have a bye, it is removed.\n\n    Args:\n        players: The player or iterable of players to toggle bye for.\n    \"\"\"\n    if not isinstance(players, Iterable):\n        players = [players]\n    for player in players:\n        if player.uid in self.tour_round._byes:\n            self.tour_round._byes.remove(player.uid)\n        else:\n            if player.pod(self.tour_round) is not None:\n                self.remove_player_from_pod(player)\n            self.tour_round.set_result(player, Player.EResult.BYE)\n</code></pre>"},{"location":"src/core/#src.core.Tournament.toggle_game_loss","title":"toggle_game_loss","text":"<pre><code>toggle_game_loss(players: Iterable[Player] | Player)\n</code></pre> <p>Toggles the game loss status for player(s).</p> <p>If a player is assigned a game loss, they are removed from their pod and marked as having lost. If they already have a game loss, it is removed.</p> <p>Parameters:</p> Name Type Description Default <code>players</code> <code>Iterable[Player] | Player</code> <p>The player or iterable of players to toggle game loss for.</p> required Source code in <code>src/core.py</code> <pre><code>@TournamentAction.action\ndef toggle_game_loss(self, players: Iterable[Player]|Player):\n    \"\"\"Toggles the game loss status for player(s).\n\n    If a player is assigned a game loss, they are removed from their pod and marked as having lost.\n    If they already have a game loss, it is removed.\n\n    Args:\n        players: The player or iterable of players to toggle game loss for.\n    \"\"\"\n    if not isinstance(players, Iterable):\n        players = [players]\n\n    for player in players:\n        if player.uid in self.tour_round._game_loss:\n            self.tour_round._game_loss.remove(player.uid)\n        else:\n            #if player.pod(self.tour_round) is not None:\n            #    self.remove_player_from_pod(player)\n            player.set_result(self.tour_round, Player.EResult.LOSS)\n</code></pre>"},{"location":"src/core/#src.core.TournamentAction","title":"TournamentAction","text":"<p>Serializable action that will be stored in tournament log and can be restored</p>"},{"location":"src/core/#src.core.TournamentAction.action","title":"action  <code>classmethod</code>","text":"<pre><code>action(func) -&gt; Callable\n</code></pre> <p>Decorator to mark a function as a tournament action.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The function to decorate.</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>The decorated function.</p> Source code in <code>src/core.py</code> <pre><code>@classmethod\ndef action(cls, func) -&gt; Callable:\n    \"\"\"Decorator to mark a function as a tournament action.\n\n    Args:\n        func: The function to decorate.\n\n    Returns:\n        The decorated function.\n    \"\"\"\n    @StandingsExport.auto_export\n    @PodsExport.auto_export\n    @functools.wraps(func)\n    def wrapper(self: Tournament, *original_args, **original_kwargs):\n        #before = self.serialize()\n        ret = func(self, *original_args, **original_kwargs)\n        cls.store(self)\n        return ret\n    return wrapper\n</code></pre>"},{"location":"src/core/#src.core.TournamentAction.load","title":"load  <code>classmethod</code>","text":"<pre><code>load(logdir='logs/default.json') -&gt; Tournament | None\n</code></pre> <p>Loads the tournament state from a log file.</p> <p>Parameters:</p> Name Type Description Default <code>logdir</code> <p>The path to the log file (default: 'logs/default.json').</p> <code>'logs/default.json'</code> <p>Returns:</p> Type Description <code>Tournament | None</code> <p>The loaded tournament instance, or None if the file does not exist.</p> Source code in <code>src/core.py</code> <pre><code>@classmethod\ndef load(cls, logdir='logs/default.json') -&gt; Tournament|None:\n    \"\"\"Loads the tournament state from a log file.\n\n    Args:\n        logdir: The path to the log file (default: 'logs/default.json').\n\n    Returns:\n        The loaded tournament instance, or None if the file does not exist.\n    \"\"\"\n    if os.path.exists(logdir):\n        cls.LOGF = logdir\n        #try:\n        with open(cls.LOGF, 'r') as f:\n            tour_json = json.load(f)\n            tour = Tournament.inflate(tour_json)\n        return tour\n        #except Exception as e:\n        #    Log.log(str(e), level=Log.Level.ERROR)\n        #    return None\n    return None\n</code></pre>"},{"location":"src/core/#src.core.TournamentAction.store","title":"store  <code>classmethod</code>","text":"<pre><code>store(tournament: Tournament)\n</code></pre> <p>Stores the tournament state to a log file.</p> <p>Parameters:</p> Name Type Description Default <code>tournament</code> <code>Tournament</code> <p>The tournament instance to store.</p> required Source code in <code>src/core.py</code> <pre><code>@classmethod\ndef store(cls, tournament: Tournament):\n    \"\"\"Stores the tournament state to a log file.\n\n    Args:\n        tournament: The tournament instance to store.\n    \"\"\"\n    if cls.LOGF is None:\n        cls.LOGF = cls.DEFAULT_LOGF\n    if cls.LOGF:\n        assert isinstance(cls.LOGF, str)\n        if not os.path.exists(os.path.dirname(cls.LOGF)):\n            os.makedirs(os.path.dirname(cls.LOGF))\n        with open(cls.LOGF, 'w') as f:\n            json.dump(tournament.serialize(), f, indent=4)\n</code></pre>"},{"location":"src/core/#src.core.TournamentConfiguration","title":"TournamentConfiguration","text":"<pre><code>TournamentConfiguration(**kwargs)\n</code></pre> <p>               Bases: <code>ITournamentConfiguration</code></p> <p>Initializes the TournamentConfiguration.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Arbitrary keyword arguments using the configuration.</p> <code>{}</code> Source code in <code>src/core.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"Initializes the TournamentConfiguration.\n\n    Args:\n        **kwargs: Arbitrary keyword arguments using the configuration.\n    \"\"\"\n    self.pod_sizes = kwargs.get('pod_sizes', [4, 3])\n    self.allow_bye = kwargs.get('allow_bye', True)\n    self.win_points = kwargs.get('win_points', 5)\n    self.bye_points = kwargs.get('bye_points', 4)\n    self.draw_points = kwargs.get('draw_points', 1)\n    self.snake_pods = kwargs.get('snake_pods', True)\n    self.n_rounds = kwargs.get('n_rounds', 5)\n    # Parse int or enum for TopCut\n    tc_val = kwargs.get('top_cut', TournamentConfiguration.TopCut.NONE)\n    if isinstance(tc_val, TournamentConfiguration.TopCut):\n        self.top_cut = tc_val\n    else:\n        # If it's already an int, map to Enum\n        try:\n            self.top_cut = TournamentConfiguration.TopCut(tc_val)\n        except Exception:\n            self.top_cut = TournamentConfiguration.TopCut.NONE\n    self.max_byes = kwargs.get('max_byes', 2)\n    self.auto_export = kwargs.get('auto_export', True)\n    self.standings_export = kwargs.get('standings_export', StandingsExport())\n    self.global_wr_seats = kwargs.get('global_wr_seats', [\n        #0.2553,\n        #0.2232,\n        #0.1847,\n        #0.1428,\n        #New data: all 50+ player events since [2024-09-30;2025-05-05]\n        0.2470,\n        0.1928,\n        0.1672,\n        0.1458,\n    ])\n</code></pre>"},{"location":"src/core/#src.core.TournamentConfiguration.max_pod_size","title":"max_pod_size  <code>property</code>","text":"<pre><code>max_pod_size\n</code></pre> <p>Returns the maximum pod size.</p> <p>Returns:</p> Type Description <p>The maximum pod size.</p>"},{"location":"src/core/#src.core.TournamentConfiguration.min_pod_size","title":"min_pod_size  <code>property</code>","text":"<pre><code>min_pod_size\n</code></pre> <p>Returns the minimum pod size.</p> <p>Returns:</p> Type Description <p>The minimum pod size.</p>"},{"location":"src/core/#src.core.TournamentConfiguration.ranking","title":"ranking  <code>staticmethod</code>","text":"<pre><code>ranking(x: Player, tour_round: Round) -&gt; tuple\n</code></pre> <p>Calculates the ranking score for a player.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Player</code> <p>The player.</p> required <code>tour_round</code> <code>Round</code> <p>The current round.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of ranking criteria.</p> Source code in <code>src/core.py</code> <pre><code>@staticmethod\n@override\ndef ranking(x:Player, tour_round: Round) -&gt; tuple:\n    \"\"\"Calculates the ranking score for a player.\n\n    Args:\n        x: The player.\n        tour_round: The current round.\n\n    Returns:\n        A tuple of ranking criteria.\n    \"\"\"\n    return (\n        x.rating(tour_round),\n        len(x.games(tour_round)),\n        np.round(x.opponent_pointrate(tour_round), 10),\n        len(x.players_beaten(tour_round)),\n        -x.average_seat([r for r in x.tour.rounds if r.seq &lt;= tour_round.seq]),\n        -x.uid if isinstance(x.uid, int) else -int(x.uid.int)\n    )\n</code></pre>"},{"location":"src/core/#src.core.TournamentContext","title":"TournamentContext","text":"<pre><code>TournamentContext(tour: Tournament, tour_round: Round, standings: list[Player])\n</code></pre> <p>Context object holding tournament state for export operations.</p> <p>Initializes the TournamentContext.</p> <p>Parameters:</p> Name Type Description Default <code>tour</code> <code>Tournament</code> <p>The tournament instance.</p> required <code>tour_round</code> <code>Round</code> <p>The specific round of the tournament.</p> required <code>standings</code> <code>list[Player]</code> <p>The list of players in the current standings.</p> required Source code in <code>src/core.py</code> <pre><code>def __init__(self, tour: Tournament, tour_round: Round, standings: list[Player]):\n    \"\"\"Initializes the TournamentContext.\n\n    Args:\n        tour: The tournament instance.\n        tour_round: The specific round of the tournament.\n        standings: The list of players in the current standings.\n    \"\"\"\n    self.tour = tour\n    self.tour_round = tour_round\n    self.standings = standings\n</code></pre>"},{"location":"src/discord_engine/","title":"src.discord_engine","text":""},{"location":"src/discord_engine/#src.discord_engine.DiscordPoster","title":"DiscordPoster","text":"<pre><code>DiscordPoster()\n</code></pre> <p>Singleton class to post messages to Discord.</p> <p>Initializes the DiscordPoster.</p> Source code in <code>src/discord_engine.py</code> <pre><code>def __init__(self):\n    \"\"\"Initializes the DiscordPoster.\"\"\"\n    if self._initialized:\n        return\n\n    self.token: str = os.getenv(\"DISCORD_TOKEN\", \"\")\n    self.guild_id = int(os.getenv(\"GUILD_ID\", 0))\n    self.channel_id = int(os.getenv(\"CHANNEL_ID\", 0))\n\n    # Set up bot\n    intents = discord.Intents.default()\n    intents.guilds = True\n    intents.messages = True\n    self.bot = commands.Bot(command_prefix=\"!\", intents=intents)\n\n    # Message queue\n    self.message_queue = asyncio.Queue()\n\n    # To detect when loop is ready\n    self.loop_ready = threading.Event()\n\n    # Background task reference\n    self.queue_task = None\n\n    @self.bot.event\n    async def on_ready():\n        # Start queue processor inside bot's event loop\n        if not self.queue_task or self.queue_task.done():\n            self.queue_task = self.bot.loop.create_task(self._process_queued_messages())\n\n    # Start bot in background thread\n    self.thread = threading.Thread(target=self._run_bot_loop, daemon=True)\n    self.thread.start()\n\n    self.loop_ready.wait()  # Ensure loop is ready\n\n    self._initialized = True\n</code></pre>"},{"location":"src/discord_engine/#src.discord_engine.DiscordPoster.__new__","title":"__new__","text":"<pre><code>__new__()\n</code></pre> <p>Creates or returns the singleton instance.</p> Source code in <code>src/discord_engine.py</code> <pre><code>def __new__(cls):\n    \"\"\"Creates or returns the singleton instance.\"\"\"\n    with cls._lock:\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance._initialized = False\n    return cls._instance\n</code></pre>"},{"location":"src/discord_engine/#src.discord_engine.DiscordPoster.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Gracefully shut down bot and background task.</p> Source code in <code>src/discord_engine.py</code> <pre><code>async def close(self):\n    \"\"\"Gracefully shut down bot and background task.\"\"\"\n    if self.loop and self.loop.is_running():\n        await self.bot.close()\n        if self.queue_task:\n            self.queue_task.cancel()\n</code></pre>"},{"location":"src/discord_engine/#src.discord_engine.DiscordPoster.instance","title":"instance  <code>classmethod</code>","text":"<pre><code>instance()\n</code></pre> <p>Get the singleton instance.</p> Source code in <code>src/discord_engine.py</code> <pre><code>@classmethod\ndef instance(cls):\n    \"\"\"Get the singleton instance.\"\"\"\n    return cls()\n</code></pre>"},{"location":"src/discord_engine/#src.discord_engine.DiscordPoster.post_message","title":"post_message","text":"<pre><code>post_message(message: str)\n</code></pre> <p>Safely post a message from any thread using self.loop.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message to post.</p> required Source code in <code>src/discord_engine.py</code> <pre><code>def post_message(self, message: str):\n    \"\"\"Safely post a message from any thread using self.loop.\n\n    Args:\n        message: The message to post.\n    \"\"\"\n    if not self.loop or not self.loop.is_running():\n        return\n\n    future = asyncio.run_coroutine_threadsafe(self.message_queue.put(message), self.loop)\n    try:\n        future.result()  # Wait for completion\n    except Exception as e:\n        print(f\"[DiscordPoster] Error posting message: {e}\")\n</code></pre>"},{"location":"src/interface/","title":"src.interface","text":""},{"location":"src/interface/#src.interface.IHashable","title":"IHashable","text":"<pre><code>IHashable(uid: UUID | None = None)\n</code></pre> <p>Interface for hashable objects with UUIDs.</p> <p>Initializes the IHashable object.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>UUID | None</code> <p>The UUID of the object. If None, a new UUID is generated.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the UUID has a collision or is of invalid type.</p> Source code in <code>src/interface.py</code> <pre><code>def __init__(self, uid: UUID|None=None):\n    \"\"\"Initializes the IHashable object.\n\n    Args:\n        uid: The UUID of the object. If None, a new UUID is generated.\n\n    Raises:\n        ValueError: If the UUID has a collision or is of invalid type.\n    \"\"\"\n    if uid:\n        if uid in self.CACHE:\n            raise ValueError('UUID collision.')\n        elif not isinstance(uid, UUID):\n            raise ValueError('UUID type error.')\n        else:\n            self.uid = uid\n    else:\n        self.uid: UUID = uuid4()\n    self.CACHE[self.uid] = self\n</code></pre>"},{"location":"src/interface/#src.interface.IHashable.get","title":"get  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>get(ID: UUID) -&gt; IHashable\n</code></pre> <p>Retrieves an object by its UUID.</p> <p>Parameters:</p> Name Type Description Default <code>ID</code> <code>UUID</code> <p>The UUID of the object.</p> required <p>Returns:</p> Type Description <code>IHashable</code> <p>The object with the specified UUID.</p> Source code in <code>src/interface.py</code> <pre><code>@classmethod\n@abstractmethod\ndef get(cls, ID: UUID) -&gt; IHashable:\n    \"\"\"Retrieves an object by its UUID.\n\n    Args:\n        ID: The UUID of the object.\n\n    Returns:\n        The object with the specified UUID.\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"src/interface/#src.interface.IPairingLogic","title":"IPairingLogic","text":"<pre><code>IPairingLogic(name: str)\n</code></pre> <p>Interface for pairing logic.</p> <p>Initializes the IPairingLogic.</p> Source code in <code>src/interface.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Initializes the IPairingLogic.\"\"\"\n    self.name = name\n</code></pre>"},{"location":"src/interface/#src.interface.IPairingLogic.advance_topcut","title":"advance_topcut","text":"<pre><code>advance_topcut(tour_round: IRound, standings: list[IPlayer]) -&gt; None\n</code></pre> <p>Advances players to the top cut.</p> <p>Parameters:</p> Name Type Description Default <code>tour_round</code> <code>IRound</code> <p>The current round.</p> required <code>standings</code> <code>list[IPlayer]</code> <p>The list of players sorted by standing.</p> required Source code in <code>src/interface.py</code> <pre><code>def advance_topcut(self, tour_round: IRound, standings: list[IPlayer]) -&gt; None:\n    \"\"\"Advances players to the top cut.\n\n    Args:\n        tour_round: The current round.\n        standings: The list of players sorted by standing.\n    \"\"\"\n    raise NotImplementedError('PairingLogic.advance_topcut not implemented - use subclass')\n</code></pre>"},{"location":"src/interface/#src.interface.IPairingLogic.make_pairings","title":"make_pairings","text":"<pre><code>make_pairings(tour_round: IRound, players: set[IPlayer], pods: Sequence[IPod]) -&gt; Sequence[IPlayer]\n</code></pre> <p>Creates pairings for a round.</p> <p>Parameters:</p> Name Type Description Default <code>tour_round</code> <code>IRound</code> <p>The current round.</p> required <code>players</code> <code>set[IPlayer]</code> <p>The set of players to pair.</p> required <code>pods</code> <code>Sequence[IPod]</code> <p>The list of available pods.</p> required <p>Returns:</p> Type Description <code>Sequence[IPlayer]</code> <p>A sequence of players who could not be paired (if any).</p> Source code in <code>src/interface.py</code> <pre><code>def make_pairings(self, tour_round:IRound, players: set[IPlayer], pods:Sequence[IPod]) -&gt; Sequence[IPlayer]:\n    \"\"\"Creates pairings for a round.\n\n    Args:\n        tour_round: The current round.\n        players: The set of players to pair.\n        pods: The list of available pods.\n\n    Returns:\n        A sequence of players who could not be paired (if any).\n    \"\"\"\n    raise NotImplementedError('PairingLogic.make_pairings not implemented - use subclass')\n</code></pre>"},{"location":"src/interface/#src.interface.IPlayer","title":"IPlayer","text":"<pre><code>IPlayer(uid: UUID | None = None)\n</code></pre> <p>               Bases: <code>IHashable</code></p> <p>Interface for a player.</p> <p>Initializes the IPlayer.</p> Source code in <code>src/interface.py</code> <pre><code>def __init__(self, uid: UUID|None=None):\n    \"\"\"Initializes the IPlayer.\"\"\"\n    super().__init__(uid=uid)\n    self.name: str = str()\n    #self.rounds: list[IRound] = list()\n    self.tour: ITournament\n</code></pre>"},{"location":"src/interface/#src.interface.IPlayer.ELocation","title":"ELocation","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum for player location.</p>"},{"location":"src/interface/#src.interface.IPlayer.EResult","title":"EResult","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum for match result.</p>"},{"location":"src/interface/#src.interface.IPod","title":"IPod","text":"<pre><code>IPod(uid: UUID | None = None)\n</code></pre> <p>               Bases: <code>IHashable</code></p> <p>Interface for a pod.</p> <p>Initializes the IPod.</p> Source code in <code>src/interface.py</code> <pre><code>def __init__(self, uid: UUID|None=None):\n    \"\"\"Initializes the IPod.\"\"\"\n    super().__init__(uid=uid)\n    self._tour: UUID\n    self._round: UUID\n    self.table: int = -1\n    self._players: list[UUID] = list()\n    self.cap: int = 0\n    self._result: set[UUID] = set()\n</code></pre>"},{"location":"src/interface/#src.interface.IPod.EResult","title":"EResult","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum for pod result.</p>"},{"location":"src/interface/#src.interface.IRound","title":"IRound","text":"<pre><code>IRound(uid: UUID | None = None)\n</code></pre> <p>               Bases: <code>IHashable</code></p> <p>Interface for a round.</p> <p>Initializes the IRound.</p> Source code in <code>src/interface.py</code> <pre><code>def __init__(self, uid: UUID|None=None):\n    \"\"\"Initializes the IRound.\"\"\"\n    super().__init__(uid=uid)\n    self.seq:int = -1\n    self.logic: IPairingLogic\n    self._tour: UUID\n    self._pods: list[UUID] = list()\n    self._players: list[UUID] = list()\n</code></pre>"},{"location":"src/interface/#src.interface.SortMethod","title":"SortMethod","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum for sorting methods.</p>"},{"location":"src/interface/#src.interface.SortOrder","title":"SortOrder","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum for sorting order.</p>"},{"location":"src/misc/","title":"src.misc","text":""},{"location":"src/misc/#src.misc.Json2Obj","title":"Json2Obj","text":"<pre><code>Json2Obj(data)\n</code></pre> <p>Converts a dictionary to an object.</p> <p>Initializes the Json2Obj.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>The dictionary to convert.</p> required Source code in <code>src/misc.py</code> <pre><code>def __init__(self, data):\n    \"\"\"Initializes the Json2Obj.\n\n    Args:\n        data: The dictionary to convert.\n    \"\"\"\n    self.__dict__ = data\n    for i in self.__dict__.keys():\n        child = self.__dict__[i]\n        if isinstance(child, dict):\n            if len(child) &gt; 0:\n                self.__dict__[i] = Json2Obj(child)\n        if isinstance(child, list):\n            self.__dict__[i] = []\n            for item in child:\n                if isinstance(item, dict):\n                    self.__dict__[i].append(Json2Obj(item))\n                else:\n                    self.__dict__[i].append(item)\n</code></pre>"},{"location":"src/misc/#src.misc.generate_player_names","title":"generate_player_names","text":"<pre><code>generate_player_names(n: int) -&gt; list[str]\n</code></pre> <p>Generates a list of random player names.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of names to generate.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of random names.</p> Source code in <code>src/misc.py</code> <pre><code>def generate_player_names(n: int) -&gt; list[str]:\n    \"\"\"Generates a list of random player names.\n\n    Args:\n        n: The number of names to generate.\n\n    Returns:\n        A list of random names.\n    \"\"\"\n    fkr = Faker()\n    names: set[str] = set()\n    while len(names) &lt; n:\n        names.add(fkr.name())\n    return list(names)\n</code></pre>"},{"location":"src/misc/#src.misc.timeit","title":"timeit","text":"<pre><code>timeit(method)\n</code></pre> <p>Decorator to measure execution time of a function.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <p>The function to measure.</p> required <p>Returns:</p> Type Description <p>The decorated function.</p> Source code in <code>src/misc.py</code> <pre><code>def timeit(method):\n    \"\"\"Decorator to measure execution time of a function.\n\n    Args:\n        method: The function to measure.\n\n    Returns:\n        The decorated function.\n    \"\"\"\n    def timed(*args, **kw):\n        sys.stdout.write('\\rt({}) ...'.format(method.__name__))\n        sys.stdout.flush()\n\n        ts = time.time()\n        result = method(*args, **kw)\n        te = time.time()\n        if 'log_time' in kw:\n            name = kw.get('log_name', method.__name__.upper())\n            kw['log_time'][name] = int((te - ts) * 1000)\n        else:\n            #print('%r  %2.2f ms' % (method.__name__, (te - ts) * 1000))\n            sys.stdout.write('\\rt({}) = {:.2f} ms\\n'.format(method.__name__, (te - ts) * 1000))\n            sys.stdout.flush()\n        return result\n    return timed\n</code></pre>"}]}